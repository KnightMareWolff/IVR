
--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\FFmpegLogReader.cpp ---
#include "FFmpegLogReader.h"
#include "Containers/StringConv.h"
#include "IVR.h" // Inclua a LogCategory

// NOVO: Inicializa o LogPrefix no construtor
FFMpegLogReader::FFMpegLogReader(void* InReadPipe, const FString& InLogPrefix)
    : ReadPipe(InReadPipe)
    , Thread(nullptr)
    , bShouldStop(false)
    , LogPrefix(InLogPrefix) // Inicializa o novo membro
{
}

FFMpegLogReader::~FFMpegLogReader()
{
    EnsureCompletion();
    // NUNCA FECHE O ReadPipe AQUI. Ele � de propriedade do IVRVideoEncoder (ou UIVRRecordingSession)
    // e ser� fechado por ele. O FFMpegLogReader apenas o usa.
}

bool FFMpegLogReader::Init()
{
    UE_LOG(LogIVR, Log, TEXT("FFMpegLogReader (%s): Thread initialized."), *LogPrefix);
    return true;
}

uint32 FFMpegLogReader::Run()
{
    UE_LOG(LogIVR, Log, TEXT("FFMpegLogReader (%s): Thread running."), *LogPrefix);
    
    // Continua lendo do pipe enquanto a thread n�o for parada
    while (!bShouldStop) // USO CORRETO: FThreadSafeBool � implicitamente convers�vel para bool
    {
        // FPlatformProcess::ReadPipe agora retorna FString.
        // Ele bloqueia at� que haja dados, ou o pipe seja fechado/processo termine.
        FString Output = FPlatformProcess::ReadPipe(ReadPipe);

        // Se a string n�o estiver vazia, significa que leu dados
        if (!Output.IsEmpty())
        {
            Output.TrimEndInline(); // Remove quebras de linha e espa�os em branco no final
            // NOVO: Usa o prefixo no log
            UE_LOG(LogIVR, Log, TEXT("%s: %s"), *LogPrefix, *Output);
        }
        else
        {
            // Se Output estiver vazia, pode significar EOF do pipe ou que n�o h� mais dados no momento.
            // Um pequeno delay evita um loop muito apertado e economiza CPU.
            FPlatformProcess::Sleep(0.01f); // Espera 10ms
        }
    }
    UE_LOG(LogIVR, Log, TEXT("FFMpegLogReader (%s): Thread stopped."), *LogPrefix);
    return 0;
}

void FFMpegLogReader::Stop()
{
    bShouldStop.AtomicSet(true); // USO CORRETO: AtomicSet para escrever
}

void FFMpegLogReader::Exit()
{
    // Limpeza final, se necess�rio
    UE_LOG(LogIVR, Log, TEXT("FFMpegLogReader (%s): Thread exited."), *LogPrefix);
}

void FFMpegLogReader::Start()
{
    Thread = FRunnableThread::Create(this, *FString::Printf(TEXT("FFmpegLogReaderThread_%s"), *LogPrefix.Replace(TEXT(" "), TEXT(""))), 0, TPri_BelowNormal);
}

void FFMpegLogReader::EnsureCompletion()
{
    if (Thread)
    {
        Stop(); // Sinaliza para parar
        Thread->WaitForCompletion(); // Espera a thread terminar
        delete Thread; // Libera a mem�ria da thread
        Thread = nullptr;
    }
}
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\FFmpegLogReader.cpp ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\IVR.cpp ---
#include "IVR.h"

DEFINE_LOG_CATEGORY(LogIVR);

#define LOCTEXT_NAMESPACE "FIVRModule"

void FIVRModule::StartupModule()
{
    UE_LOG(LogIVR, Log, TEXT("IVR Module Started"));
}

void FIVRModule::ShutdownModule()
{
    UE_LOG(LogIVR, Log, TEXT("IVR Module Shutdown"));
}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FIVRModule, IVR)
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\IVR.cpp ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\IVRGlobalStatics.cpp ---
// Fill out your copyright notice in the Description page of Project Settings.


#include "IVRGlobalStatics.h"
#include "HAL/PlatformMisc.h"  

FIVR_SystemErrorDetails UIVRGlobalStatics::GetLastSystemErrorDetails()
{
    FIVR_SystemErrorDetails ErrorDetails;

    // 1. Captura o �ltimo erro gerado pelo sistema operacional na thread atual
    ErrorDetails.ErrorCode = FPlatformMisc::GetLastError(); // FPlatformMisc::GetLastError() retorna uint32, ser� convertido para int32

    // 2. Obt�m a mensagem de erro do sistema para esse c�digo
    // Define um buffer est�tico (ou alocado dinamicamente se a mensagem puder ser muito grande)
    // para FPlatformMisc::GetSystemErrorMessage escrever a mensagem.
    // UE_ARRAY_COUNT � uma macro �til para obter o tamanho de arrays em TCHARs.
    TCHAR ErrorBuffer[1024]; // Um buffer de 1KB deve ser suficiente para a maioria das mensagens de erro

    // Chama GetSystemErrorMessage para preencher o buffer
    FPlatformMisc::GetSystemErrorMessage(ErrorBuffer, UE_ARRAY_COUNT(ErrorBuffer), ErrorDetails.ErrorCode);

    // Converte o conte�do do buffer para FString
    ErrorDetails.ErrorDescription = ErrorBuffer;

    // Remove quebras de linha/espa�os em branco indesejados do final da string
    ErrorDetails.ErrorDescription.TrimEndInline();

    // 3. Lida com casos onde a mensagem de erro pode estar vazia ou n�o reconhecida
    if (ErrorDetails.ErrorDescription.IsEmpty())
    {
        ErrorDetails.ErrorDescription = FString::Printf(TEXT("Failed to retrieve system error message for code %d. This error code might not be recognized by the system or is generic."), ErrorDetails.ErrorCode);
    }

    return ErrorDetails;
}

--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\IVRGlobalStatics.cpp ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\IVR_PipeWrapper.cpp ---
// Fill out your copyright notice in the Description page of Project Settings.
// IVRPipeWrapper.cpp
#include "IVR_PipeWrapper.h"
#include "IVRGlobalStatics.h" // Para o tratamento de erros
#include "Misc/Guid.h" // Para gerar GUIDs
#include "Misc/FileHelper.h" // Para FFileHelper::DeleteFile

// Defini��o de LogCategory
DEFINE_LOG_CATEGORY(LogIVRPipeWrapper);

// Constructor
FIVR_PipeWrapper::FIVR_PipeWrapper()
    : FullPipePath(TEXT(""))
    , bIsCreatedAndConnected(false)
{
#if PLATFORM_WINDOWS
    PipeHandle = INVALID_HANDLE_VALUE;
#elif PLATFORM_LINUX || PLATFORM_MAC
    FileDescriptor = -1;
    PipeHandle = -1;
#endif
}

// Destructor
FIVR_PipeWrapper::~FIVR_PipeWrapper()
{
    Close(); // Garante que o pipe � fechado quando o objeto � destru�do
}

// Create Pipe
bool FIVR_PipeWrapper::Create(const FIVR_PipeSettings& Settings, const FString& SessionID, int32 InWidth, int32 InHeight)
{
    if (IsValid())
    {
        UE_LOG(LogIVRPipeWrapper, Warning, TEXT("Pipe '%s' already created. Closing and recreating."), *FullPipePath);
        Close();
    }

    PipeSettings = Settings;
    FString BasePipeName = Settings.BasePipeName;

    // Construir o caminho completo do pipe.
    // Para Windows: \.\pipe\<BasePipeName>_<SessionID>
    // Para POSIX: /tmp/<BasePipeName>_<SessionID> (ou outro diret�rio tempor�rio seguro)
    FString UniquePipeName = FString::Printf(TEXT("%s%s"), *BasePipeName , *SessionID);

#if PLATFORM_WINDOWS
    FullPipePath = FString::Printf(TEXT("\\\\.\\pipe\\%s"), *UniquePipeName);

    DWORD OpenMode = PIPE_ACCESS_OUTBOUND; // UE escreve, FFmpeg l�
    DWORD PipeMode = PIPE_TYPE_BYTE; // Modo byte stream
    if (Settings.bBlockingMode)
    {
        PipeMode |= PIPE_WAIT; // Modo bloqueante
    }
    else
    {
        PipeMode |= PIPE_NOWAIT; // Modo n�o-bloqueante
    }

    DWORD CalculatedBufferSize = Settings.OutBufferSize; // Valor padr�o da PipeSettings
    if (InWidth > 0 && InHeight > 0)
    {
        // Assumindo BGRA (4 bytes por pixel)
        CalculatedBufferSize = InWidth * InHeight * 4;
        // O Windows pode ter um limite m�ximo para o buffer de Named Pipes.
        // Um valor muito grande pode ser internamente truncado.
        // 8MB (para 1080p BGRA) � geralmente OK, mas � bom ter em mente.
    }

    // Cria a inst�ncia do Named Pipe
    PipeHandle = CreateNamedPipe(
        *FullPipePath,            // Nome do pipe
        OpenMode,                 // Modo de abertura
        PipeMode,                 // Modo do pipe
        1,                        // N�mero m�ximo de inst�ncias
        CalculatedBufferSize,     // Tamanho do buffer de sa�da
        CalculatedBufferSize,     // Tamanho do buffer de entrada
        NMPWAIT_USE_DEFAULT_WAIT, // Timeout padr�o para cliente conectar
        NULL);                    // Atributos de seguran�a (padr�o)

    FIVR_SystemErrorDetails Det = UIVRGlobalStatics::GetLastSystemErrorDetails();
    if (Det.ErrorCode != 0)
    {
        UE_LOG(LogIVR, Error, TEXT("Failed CreateNamedPipe %s. Error: %d Description: %s"), *FullPipePath, Det.ErrorCode,*Det.ErrorDescription);
        return false;
    }

    if (!PipeHandle)
    {
        UE_LOG(LogIVR, Error, TEXT("Failed to create Windows Named Pipe '%s'. Error: Null Pointer"), *FullPipePath);
        return false;
    }

    // Apenas defina bIsCreatedAndConnected como true, pois o pipe foi criado com sucesso.
    bIsCreatedAndConnected = true;
    UE_LOG(LogIVR, Log, TEXT("Windows Named Pipe '%s' created successfully and awaiting client connection."), *FullPipePath);


#elif PLATFORM_LINUX || PLATFORM_MAC
    // FIFOs s�o arquivos no sistema de arquivos. Usar um diret�rio tempor�rio seguro.
    FullPipePath = FPaths::Combine(FPaths::Get=+TempDir(), UniquePipeName);

    // Tenta deletar o FIFO se ele j� existir, para garantir um novo come�o limpo.
    // mkfifo falharia se o arquivo j� existisse.
    if (access(TCHAR_TO_UTF8(*FullPipePath), F_OK) == 0)
    {
        unlink(TCHAR_TO_UTF8(*FullPipePath));
        UE_LOG(LogIVR, Warning, TEXT("Removed existing FIFO file '%s'."), *FullPipePath);
    }

    // Criar o FIFO (mkfifo)
    // Permiss�es 0666 para read/write para owner, group, others.
    if (mkfifo(TCHAR_TO_UTF8(*FullPipePath), 0666) == -1)
    {
        UE_LOG(LogIVR, Error, TEXT("Failed to create FIFO '%s'. Error: %s"), *FullPipePath, UTF8_TO_TCHAR(strerror(errno)));
        return false;
    }
    
    // Abrir o FIFO para escrita. O_WRONLY para escrita, O_NONBLOCK para n�o bloquear no open.
    // Se bBlockingMode for true, remove O_NONBLOCK para que open() bloqueie at� um leitor se conectar.
    int OpenFlags = O_WRONLY;
    if (!Settings.bBlockingMode)
    {
        OpenFlags |= O_NONBLOCK;
    }

    // Abrir o FIFO. Isso pode bloquear se bBlockingMode for true e n�o houver leitor ainda.
    UE_LOG(LogIVR, Log, TEXT("Opening FIFO '%s' for writing... (will block if no reader)"), *FullPipePath);
    FileDescriptor = open(TCHAR_TO_UTF8(*FullPipePath), OpenFlags);

    if (FileDescriptor == -1)
    {
        UE_LOG(LogIVR, Error, TEXT("Failed to open FIFO '%s' for writing. Error: %s"), *FullPipePath, UTF8_TO_TCHAR(strerror(errno)));
        unlink(TCHAR_TO_UTF8(*FullPipePath)); // Limpa o FIFO que foi criado
        return false;
    }
    bIsCreatedAndConnected = true;
    UE_LOG(LogIVR, Log, TEXT("FIFO '%s' opened successfully for writing."), *FullPipePath);

#else // Outras plataformas (se houver)
    UE_LOG(LogIVR, Error, TEXT("FIVR_PipeWrapper::Create not implemented for this platform."));
    return false;
#endif

    return bIsCreatedAndConnected;

}

// NOVO M�TODO DE CONEX�O
bool FIVR_PipeWrapper::Connect()
{
#if PLATFORM_WINDOWS
    if (!IsValid())
    {
        UE_LOG(LogIVRPipeWrapper, Error, TEXT("Cannot connect. Pipe handle is invalid for '%s'."), *FullPipePath);
        return false;
    }

    UE_LOG(LogIVRPipeWrapper, Log, TEXT("Awaiting client connection for pipe: %s"), *FullPipePath);

    // ConnectNamedPipe bloquear� at� que um cliente se conecte.
    // ERROR_PIPE_CONNECTED significa que o pipe j� estava conectado (em caso de chamadas sucessivas),
    // o que � um sucesso.
    BOOL bSuccess = ConnectNamedPipe(PipeHandle, NULL);
    if (!bSuccess && GetLastError() != ERROR_PIPE_CONNECTED)
    {
        DWORD ErrorCode = GetLastError();
        UE_LOG(LogIVRPipeWrapper, Error, TEXT("Failed to connect Named Pipe '%s'. Error: %d"), *FullPipePath, ErrorCode);
        CloseHandle(PipeHandle);
        PipeHandle = INVALID_HANDLE_VALUE;
        return false;
    }

    UE_LOG(LogIVRPipeWrapper, Log, TEXT("Named Pipe '%s' connected successfully."), *FullPipePath);
    return true;
#else
    UE_LOG(LogIVRPipeWrapper, Error, TEXT("Connect() not implemented for non-Windows platforms."));
    return false;
#endif
}


// Write to Pipe
int32 FIVR_PipeWrapper::Write(const uint8* Data, int32 NumBytes)
{
    if (!IsValid())
    {
        UE_LOG(LogIVR, Error, TEXT("Attempted to write to an invalid or uninitialized pipe."));
        return false;
    }

#if PLATFORM_WINDOWS
    DWORD BytesWritten;
    if (!WriteFile(PipeHandle, Data, NumBytes, &BytesWritten, nullptr))
    {
        UE_LOG(LogIVR, Error, TEXT("Failed to write to Windows Named Pipe. Error: %d"), GetLastError());
        return false;
    }

    if (BytesWritten != (DWORD)NumBytes)
    {
        UE_LOG(LogIVRPipeWrapper, Error, TEXT("Incomplete write to Named Pipe '%s'. Wrote %d bytes."), *FullPipePath, NumBytes);
        return false;
    }

    return true;

#elif PLATFORM_LINUX || PLATFORM_MAC
    ssize_t BytesWritten = write(FileDescriptor, Data, NumBytes);
    if (BytesWritten == -1)
    {
        UE_LOG(LogIVR, Error, TEXT("Failed to write to FIFO. Error: %s"), UTF8_TO_TCHAR(strerror(errno)));
        return false;
    }
    return true;

#else // Outras plataformas
    return false;
#endif

}

// Close Pipe
void FIVR_PipeWrapper::Close()
{
    if (!IsValid())
    {
        return; // J� fechado ou nunca foi v�lido
    }

#if PLATFORM_WINDOWS
    if (PipeHandle != INVALID_HANDLE_VALUE)
    {
        FlushFileBuffers(PipeHandle); // Garante que todos os dados sejam gravados
        DisconnectNamedPipe(PipeHandle); // Desconecta o cliente
        CloseHandle(PipeHandle);         // Fecha o handle
        PipeHandle = INVALID_HANDLE_VALUE;
        UE_LOG(LogIVR, Log, TEXT("Windows Named Pipe '%s' closed."), *FullPipePath);
    }
#elif PLATFORM_LINUX || PLATFORM_MAC
    if (FileDescriptor != -1)
    {
        close(FileDescriptor); // Fecha o descritor de arquivo
        FileDescriptor = -1;
        UE_LOG(LogIVR, Log, TEXT("FIFO '%s' file descriptor closed."), *FullPipePath);
    }
    // Remove o arquivo FIFO do sistema de arquivos
    if (!FullPipePath.IsEmpty() && access(TCHAR_TO_UTF8(*FullPipePath), F_OK) == 0)
    {
        unlink(TCHAR_TO_UTF8(*FullPipePath));
        UE_LOG(LogIVR, Log, TEXT("FIFO file '%s' unlinked."), *FullPipePath);
    }
#else // Outras plataformas
    // No-op
#endif
    bIsCreatedAndConnected = false;
    FullPipePath = TEXT(""); // Limpa o caminho
}

bool FIVR_PipeWrapper::IsValid() const
{
#if PLATFORM_WINDOWS
    return PipeHandle != INVALID_HANDLE_VALUE && bIsCreatedAndConnected;
#elif PLATFORM_LINUX || PLATFORM_MAC
    return FileDescriptor != -1 && bIsCreatedAndConnected;
#else // Outras plataformas
    return false;
#endif
}

FString FIVR_PipeWrapper::GetFullPipeName() const
{
    return FullPipePath;
}
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\IVR_PipeWrapper.cpp ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Components\IVRCaptureComponent.cpp ---
// D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Components\IVRCaptureComponent.cpp

#include "Components/IVRCaptureComponent.h"
#include "Recording/IVRRecordingManager.h" 
#include "Recording/IVRRecordingSession.h"
#include "Recording/IVRRenderFrameSource.h" 
#include "IVR.h"
#include "Engine/World.h" 
#include "Kismet/KismetMathLibrary.h"
#include "Misc/Paths.h" 
#include "Misc/FileHelper.h" 
#include "HAL/PlatformFileManager.h" 
#include "CineCameraComponent.h" 

#include "Engine/Texture2D.h" 
#include "RenderingThread.h" 

UIVRCaptureComponent::UIVRCaptureComponent()
{
    PrimaryComponentTick.bCanEverTick = true;
    RecordingStartTimeSeconds = 0.0f;

    FramePool = CreateDefaultSubobject<UIVRFramePool>(TEXT("IVRFramePool"));
    OwnedVideoCaptureComponent = nullptr; 
    ActualFrameWidth = 0;
    ActualFrameHeight = 0;
    RealTimeOutputTexture2D = nullptr; 
}

void UIVRCaptureComponent::BeginDestroy()
{
    if (CurrentFrameSource)
    {
        CurrentFrameSource->Shutdown();
        CurrentFrameSource = nullptr;
    }
    
    if (RealTimeOutputTexture2D)
    {
        RealTimeOutputTexture2D->ReleaseResource(); 
        RealTimeOutputTexture2D = nullptr;
    }

    if (OwnedVideoCaptureComponent && OwnedVideoCaptureComponent->GetOwner() == this->GetOwner() && OwnedVideoCaptureComponent->GetOuter() == this)
    {
        OwnedVideoCaptureComponent->DestroyComponent(); 
        OwnedVideoCaptureComponent = nullptr;
    }
    Super::BeginDestroy();
}

void UIVRCaptureComponent::BeginPlay()
{
    Super::BeginPlay();

    switch (VideoSettings.FrameSourceType)
    {
    case EIVRFrameSourceType::Simulated:
    {
        CurrentFrameSource = NewObject<UIVRSimulatedFrameSource>(this);
        Cast<UIVRSimulatedFrameSource>(CurrentFrameSource)->Initialize(GetWorld(), VideoSettings, FramePool, VideoSettings.IVR_FrameTint);
    }break;
    case EIVRFrameSourceType::RenderTarget:
    {
        CurrentFrameSource = NewObject<UIVRRenderFrameSource>(this);

        AActor* OwnerActor = GetOwner();
        USceneCaptureComponent2D* ExistingCaptureComp = nullptr;
        UCineCameraComponent* ExistingCineCamComp = nullptr;

        if (OwnerActor)
        {
            ExistingCaptureComp = OwnerActor->FindComponentByClass<USceneCaptureComponent2D>();
            ExistingCineCamComp = OwnerActor->FindComponentByClass<UCineCameraComponent>();
        }

        if (ExistingCaptureComp)
        {
            OwnedVideoCaptureComponent = ExistingCaptureComp;
            UE_LOG(LogIVR, Log, TEXT("UIVRCaptureComponent: Found existing USceneCaptureComponent2D on owner Actor. Using it for capture."));
        }
        else if (ExistingCineCamComp)
        {
            // Se um CineCameraComponent existe, criamos nosso prprio USceneCaptureComponent2D
            // e copiamos suas configuraes relevantes.
            OwnedVideoCaptureComponent = NewObject<USceneCaptureComponent2D>(this, TEXT("OwnedVideoCaptureComponent_FromCineCam"));
            if (OwnedVideoCaptureComponent)
            {
                OwnedVideoCaptureComponent->RegisterComponent();
                if (GetAttachParent()) 
                {
                    OwnedVideoCaptureComponent->AttachToComponent(GetAttachParent(), FAttachmentTransformRules::KeepRelativeTransform);
                }
                else 
                {
                    OwnedVideoCaptureComponent->AttachToComponent(this, FAttachmentTransformRules::KeepRelativeTransform);
                }
                UE_LOG(LogIVR, Log, TEXT("UIVRCaptureComponent: Created and attached new USceneCaptureComponent2D configured from existing UCineCameraComponent."));

                // Copiar configuraes de cmera relevantes do CineCam para nosso USceneCaptureComponent2D
                OwnedVideoCaptureComponent->SetRelativeLocation(ExistingCineCamComp->GetRelativeLocation());
                OwnedVideoCaptureComponent->SetRelativeRotation(ExistingCineCamComp->GetRelativeRotation());
                OwnedVideoCaptureComponent->FOVAngle = ExistingCineCamComp->FieldOfView; 
                OwnedVideoCaptureComponent->PostProcessSettings = ExistingCineCamComp->PostProcessSettings; // Copiar todas as configuraes de ps-processamento
            }
            else
            {
                UE_LOG(LogIVR, Error, TEXT("UIVRCaptureComponent: Failed to create new USceneCaptureComponent2D from CineCameraComponent. RenderTarget capture will likely fail."));
            }
        }
        else
        {
            // Se nenhum componente de captura existente foi encontrado, cria um USceneCaptureComponent2D padro.
            OwnedVideoCaptureComponent = NewObject<USceneCaptureComponent2D>(this, TEXT("OwnedVideoCaptureComponent_Default"));
            if (OwnedVideoCaptureComponent)
            {
                OwnedVideoCaptureComponent->RegisterComponent(); 
                if (GetAttachParent()) 
                {
                    OwnedVideoCaptureComponent->AttachToComponent(GetAttachParent(), FAttachmentTransformRules::KeepRelativeTransform);
                }
                else 
                {
                    OwnedVideoCaptureComponent->AttachToComponent(this, FAttachmentTransformRules::KeepRelativeTransform);
                }
                UE_LOG(LogIVR, Log, TEXT("UIVRCaptureComponent: Created and attached new default USceneCaptureComponent2D."));
            }
            else
            {
                UE_LOG(LogIVR, Error, TEXT("UIVRCaptureComponent: Failed to create new default USceneCaptureComponent2D. RenderTarget capture will likely fail."));
            }
        }

        if (OwnedVideoCaptureComponent)
        {
            // Aplicar configuraes da VideoSettings (podem sobrescrever as copiadas, se houver)
            OwnedVideoCaptureComponent->ProjectionType = ECameraProjectionMode::Perspective;
            OwnedVideoCaptureComponent->FOVAngle = VideoSettings.IVR_CineCameraFOV; 
            OwnedVideoCaptureComponent->CaptureSource = ESceneCaptureSource::SCS_FinalColorLDR;
            OwnedVideoCaptureComponent->bCaptureEveryFrame = true;

            // Define a localizao e rotao relativas ao componente pai como padro (0,0,0)
            OwnedVideoCaptureComponent->SetRelativeLocation(FVector::ZeroVector);
            OwnedVideoCaptureComponent->SetRelativeRotation(FRotator::ZeroRotator);

            // Aplicar configuraes de ps-processamento do VideoSettings
            if (VideoSettings.IVR_EnableCinematicPostProcessing)
            {
                OwnedVideoCaptureComponent->PostProcessSettings.bOverride_AutoExposureMethod = true;
                OwnedVideoCaptureComponent->PostProcessSettings.AutoExposureMethod = EAutoExposureMethod::AEM_Histogram;
            }
            else
            {
                OwnedVideoCaptureComponent->PostProcessSettings.bOverride_AutoExposureMethod = false;
            }
        }
        Cast<UIVRRenderFrameSource>(CurrentFrameSource)->Initialize(GetWorld(), VideoSettings, FramePool, OwnedVideoCaptureComponent);
    }break;
    case EIVRFrameSourceType::Folder: // CORRIGIDO: Adicionado case para Folder
    {
        CurrentFrameSource = NewObject<UIVRFolderFrameSource>(this);
        Cast<UIVRFolderFrameSource>(CurrentFrameSource)->Initialize(GetWorld(), VideoSettings, FramePool);
    }break;
    case EIVRFrameSourceType::VideoFile: // CORRIGIDO: Adicionado case para VideoFile
    {
        CurrentFrameSource = NewObject<UIVRVideoFrameSource>(this);
        Cast<UIVRVideoFrameSource>(CurrentFrameSource)->Initialize(GetWorld(), VideoSettings, FramePool);
    }break;
    case EIVRFrameSourceType::Webcam: // CORRIGIDO: Adicionado case para Webcam
    {
        CurrentFrameSource = NewObject<UIVRWebcamFrameSource>(this);
        Cast<UIVRWebcamFrameSource>(CurrentFrameSource)->Initialize(GetWorld(), VideoSettings, FramePool);
    }break;
    default: // Fallback se o tipo de fonte no for reconhecido (nunca deveria acontecer agora)
    {
        UE_LOG(LogIVR, Error, TEXT("UIVRCaptureComponent: Unknown FrameSourceType selected (%d). Defaulting to RenderTarget."), (int32)VideoSettings.FrameSourceType);
        CurrentFrameSource = NewObject<UIVRRenderFrameSource>(this); // Fallback to RenderTarget

        // Lgica de fallback para USceneCaptureComponent2D
        AActor* OwnerActor = GetOwner(); 
        USceneCaptureComponent2D* ExistingCaptureComp = nullptr;
        UCineCameraComponent* ExistingCineCamComp = nullptr;

        if (OwnerActor)
        {
            ExistingCaptureComp = OwnerActor->FindComponentByClass<USceneCaptureComponent2D>();
            ExistingCineCamComp = OwnerActor->FindComponentByClass<UCineCameraComponent>();
        }

        if (ExistingCaptureComp)
        {
            OwnedVideoCaptureComponent = ExistingCaptureComp;
        }
        else if (ExistingCineCamComp)
        {
            OwnedVideoCaptureComponent = NewObject<USceneCaptureComponent2D>(this, TEXT("OwnedVideoCaptureComponent_FromCineCam_Default"));
            if (OwnedVideoCaptureComponent)
            {
                OwnedVideoCaptureComponent->RegisterComponent();
                if (GetAttachParent()) { OwnedVideoCaptureComponent->AttachToComponent(GetAttachParent(), FAttachmentTransformRules::KeepRelativeTransform); }
                else { OwnedVideoCaptureComponent->AttachToComponent(this, FAttachmentTransformRules::KeepRelativeTransform); }
                OwnedVideoCaptureComponent->SetRelativeLocation(ExistingCineCamComp->GetRelativeLocation());
                OwnedVideoCaptureComponent->SetRelativeRotation(ExistingCineCamComp->GetRelativeRotation());
                OwnedVideoCaptureComponent->FOVAngle = ExistingCineCamComp->FieldOfView;
                OwnedVideoCaptureComponent->PostProcessSettings = ExistingCineCamComp->PostProcessSettings;
            }
        }
        else
        {
            OwnedVideoCaptureComponent = NewObject<USceneCaptureComponent2D>(this, TEXT("OwnedVideoCaptureComponent_Default_Fallback"));
            if (OwnedVideoCaptureComponent) // Registrar e anexar o componente de fallback recm-criado
            {
                OwnedVideoCaptureComponent->RegisterComponent();
                if (GetAttachParent()) { OwnedVideoCaptureComponent->AttachToComponent(GetAttachParent(), FAttachmentTransformRules::KeepRelativeTransform); }
                else { OwnedVideoCaptureComponent->AttachToComponent(this, FAttachmentTransformRules::KeepRelativeTransform); }
            }
        }

        if (OwnedVideoCaptureComponent) // Apenas se o componente de fallback foi criado/encontrado com sucesso
        {
            OwnedVideoCaptureComponent->ProjectionType = ECameraProjectionMode::Perspective;
            OwnedVideoCaptureComponent->FOVAngle = VideoSettings.IVR_CineCameraFOV;
            OwnedVideoCaptureComponent->CaptureSource = ESceneCaptureSource::SCS_FinalColorLDR;
            OwnedVideoCaptureComponent->bCaptureEveryFrame = true;
            OwnedVideoCaptureComponent->SetRelativeLocation(FVector::ZeroVector);
            OwnedVideoCaptureComponent->SetRelativeRotation(FRotator::ZeroRotator);
            if (VideoSettings.IVR_EnableCinematicPostProcessing)
            {
                OwnedVideoCaptureComponent->PostProcessSettings.bOverride_AutoExposureMethod = true;
                OwnedVideoCaptureComponent->PostProcessSettings.AutoExposureMethod = EAutoExposureMethod::AEM_Histogram;
            }
            else
            {
                OwnedVideoCaptureComponent->PostProcessSettings.bOverride_AutoExposureMethod = false;
            }
        } else {
             UE_LOG(LogIVR, Error, TEXT("UIVRCaptureComponent: Failed to create default OwnedVideoCaptureComponent for fallback. RenderTarget capture will not function."));
        }
        Cast<UIVRRenderFrameSource>(CurrentFrameSource)->Initialize(GetWorld(), VideoSettings, FramePool, OwnedVideoCaptureComponent);
    }break;
    }

    if (CurrentFrameSource)
    {
        // A lgica de obteno de ActualFrameWidth/Height para fontes de hardware (Webcam/VideoFile)
        // precisa de tempo para o worker thread iniciar e obter as dimenses reais.
        // As fontes Simulated, RenderTarget e Folder usam as dimenses do VideoSettings.
        if (UIVRWebcamFrameSource* WebcamSource = Cast<UIVRWebcamFrameSource>(CurrentFrameSource))
        {
            // D um tempo para o worker da webcam obter as dimenses reais
            for (int i = 0; i < 10; ++i) 
            {
                ActualFrameWidth = WebcamSource->GetActualFrameWidth();
                ActualFrameHeight = WebcamSource->GetActualFrameHeight();
                if (ActualFrameWidth > 0 && ActualFrameHeight > 0)
                {
                    UE_LOG(LogIVR, Log, TEXT("UIVRCaptureComponent: Webcam actual resolution determined: %dx%d after %d retries."), ActualFrameWidth, ActualFrameHeight, i+1);
                    break;
                }
                FPlatformProcess::Sleep(0.01f); // Espera 10ms
            }

            if (ActualFrameWidth <= 0 || ActualFrameHeight <= 0)
            {
                // Fallback para as dimenses do VideoSettings se a webcam no reportar vlido
                ActualFrameWidth = VideoSettings.Width;
                ActualFrameHeight = VideoSettings.Height;
                UE_LOG(LogIVR, Warning, TEXT("UIVRCaptureComponent: Webcam reported invalid resolution (%dx%d) after polling. Using VideoSettings for initial FramePool."), ActualFrameWidth, ActualFrameHeight);
            }
        }
        else if (UIVRVideoFrameSource* VideoFileSource = Cast<UIVRVideoFrameSource>(CurrentFrameSource))
        {
            // D um tempo para o worker do arquivo de vdeo obter as dimenses reais
            for (int i = 0; i < 10; ++i)
            {
                ActualFrameWidth = VideoFileSource->GetActualFrameWidth();
                ActualFrameHeight = VideoFileSource->GetActualFrameHeight();
                if (ActualFrameWidth > 0 && ActualFrameHeight > 0)
                {
                    UE_LOG(LogIVR, Log, TEXT("UIVRCaptureComponent: VideoFile actual resolution determined: %dx%d after %d retries."), ActualFrameWidth, ActualFrameHeight, i+1);
                    break;
                }
                FPlatformProcess::Sleep(0.01f);
            }

            if (ActualFrameWidth <= 0 || ActualFrameHeight <= 0)
            {
                // Fallback para as dimenses do VideoSettings se o arquivo no reportar vlido
                ActualFrameWidth = VideoSettings.Width;
                ActualFrameHeight = VideoSettings.Height;
                UE_LOG(LogIVR, Warning, TEXT("UIVRCaptureComponent: VideoFileSource reported invalid resolution (%dx%d) after polling. Using VideoSettings for initial FramePool."), ActualFrameWidth, ActualFrameHeight);
            }
        }
        else // Para RenderTarget, Folder, Simulated, use as configuraes do VideoSettings diretamente
        {
            ActualFrameWidth = VideoSettings.Width;
            ActualFrameHeight = VideoSettings.Height;
        }


        FramePool->Initialize(FramePoolSize, ActualFrameWidth, ActualFrameHeight, true); 
        
        CurrentFrameSource->OnFrameAcquired.AddUObject(this, &UIVRCaptureComponent::OnFrameAcquiredFromSource);
        UE_LOG(LogIVR, Log, TEXT("UIVRCaptureComponent: Frame source '%s' initialized and delegate bound. FramePool initially configured for %dx%d."), *CurrentFrameSource->GetName(), ActualFrameWidth, ActualFrameHeight);
    }
    else
    {
        UE_LOG(LogIVR, Error, TEXT("UIVRCaptureComponent: Failed to create CurrentFrameSource. Recording will not function correctly."));
    }
}

void UIVRCaptureComponent::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
    StopRecording(); 

    if (CurrentFrameSource)
    {
        CurrentFrameSource->Shutdown();
        CurrentFrameSource = nullptr;
        UE_LOG(LogIVR, Log, TEXT("UIVRCaptureComponent: CurrentFrameSource shutdown."));
    }
    // No destrumos OwnedVideoCaptureComponent aqui, pois ele pode ter sido apenas referenciado
    // ou criado como parte de um fallback e ser destrudo com o prprio UIVRCaptureComponent.
    OwnedVideoCaptureComponent = nullptr; 

    Super::EndPlay(EndPlayReason); 
}

void UIVRCaptureComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
{
    Super::TickComponent(DeltaTime, TickType, ThisTickFunction);

    if (OwnedVideoCaptureComponent && VideoSettings.FrameSourceType == EIVRFrameSourceType::RenderTarget && VideoSettings.IVR_FollowActor)
    {
        if (VideoSettings.IVR_FollowActor->IsValidLowLevel())
        {
            FRotator CameraRot = UKismetMathLibrary::FindLookAtRotation(
                OwnedVideoCaptureComponent->GetComponentLocation(),
                VideoSettings.IVR_FollowActor->GetActorLocation()
            );
            OwnedVideoCaptureComponent->SetWorldRotation(CameraRot);
        }
        else
        {
            UE_LOG(LogIVR, Warning, TEXT("UIVRCaptureComponent: IVR_FollowActor is no longer valid. Disabling follow behavior."));
            VideoSettings.IVR_FollowActor = nullptr;
        }
    }

    if (bIsRecording) 
    {
        if (CurrentFrameSource && VideoSettings.FrameSourceType == EIVRFrameSourceType::RenderTarget)
        {
            Cast<UIVRRenderFrameSource>(CurrentFrameSource)->ProcessRenderQueue();
        }

        if (CurrentSession) 
        {
            CurrentTakeTime += DeltaTime;
            
            if (CurrentTakeTime >= TakeDuration)
            {
                EndCurrentTake();
                
                if (bAutoStartNewTake)
                {
                    StartNewTake(); 
                }
            }
        }
    }
}


void UIVRCaptureComponent::StartRecording()
{
    AsyncTask(ENamedThreads::GameThread, [this]()
        {
            if (!bIsRecording)
            {
                bIsRecording = true;
                CurrentTakeNumber = 0; 
                RecordingStartTimeSeconds = GetWorld()->GetTimeSeconds();

                if (CurrentFrameSource)
                {
                    CurrentFrameSource->StartCapture(); 
                    UE_LOG(LogIVR, Log, TEXT("UIVRCaptureComponent: Frame source capture started."));

                    // --- IN�CIO: Ajuste VideoSettings.FPS com base no FrameSourceType ativo ---
                    // Isso garante que o processo FFmpeg (via UIVRVideoEncoder) use a taxa de quadros de entrada correta,
                    // alinhando com a velocidade real de produ��o de frames pelo CurrentFrameSource.
                    if (VideoSettings.FrameSourceType == EIVRFrameSourceType::Folder)
                    {
                        VideoSettings.FPS = VideoSettings.IVR_FolderPlaybackFPS;
                        UE_LOG(LogIVR, Log, TEXT("UIVRCaptureComponent: Ajustando FPS da sess�o para IVR_FolderPlaybackFPS: %.2f"), VideoSettings.FPS);
                    }
                    else if (VideoSettings.FrameSourceType == EIVRFrameSourceType::Webcam)
                    {
                        // Garante que o FPS da Webcam seja usado. IVR_WebcamFPS � o alvo para a produ��o de frames.
                        VideoSettings.FPS = VideoSettings.IVR_WebcamFPS;
                        UE_LOG(LogIVR, Log, TEXT("UIVRCaptureComponent: Ajustando FPS da sess�o para IVR_WebcamFPS: %.2f"), VideoSettings.FPS);
                    }
                    else if (VideoSettings.FrameSourceType == EIVRFrameSourceType::VideoFile)
                    {
                        // Para VideoFile, o FPS de reprodu��o efetivo � determinado pelo FPS nativo do v�deo * velocidade de reprodu��o.
                        UIVRVideoFrameSource* VideoFileSource = Cast<UIVRVideoFrameSource>(CurrentFrameSource);
                        if (VideoFileSource)
                        {
                            // Consulta o FPS efetivo real. Isso pode levar algumas tentativas para o worker thread inicializar.
                            float effectiveFPS = 0.0f;
                            for (int i = 0; i < 10; ++i) // Consulta por no m�ximo 100ms (10 * 10ms de sleep)
                            {
                                effectiveFPS = VideoFileSource->GetEffectivePlaybackFPS();
                                if (effectiveFPS > 0.0f)
                                {
                                    break;
                                }
                                FPlatformProcess::Sleep(0.01f); // Espera 10ms
                            }
                            if (effectiveFPS > 0.0f)
                            {
                                VideoSettings.FPS = effectiveFPS;
                                UE_LOG(LogIVR, Log, TEXT("UIVRCaptureComponent: Ajustando FPS da sess�o para FPS efetivo do VideoFile: %.2f"), VideoSettings.FPS);
                            }
                            else
                            {
                                UE_LOG(LogIVR, Warning, TEXT("UIVRCaptureComponent: N�o foi poss�vel determinar o FPS efetivo do VideoFile. Usando VideoSettings.FPS padr�o (%.2f) para a entrada do FFmpeg. A velocidade de sa�da do v�deo pode estar incorreta."), VideoSettings.FPS);
                            }
                        }
                    }
                    // Para Simulated e RenderTarget, VideoSettings.FPS j� � o FPS pretendido, nenhuma sobrescrita � necess�ria.
                    // --- FIM: Ajuste VideoSettings.FPS ---

                    // Atualiza as dimens�es reais no momento do StartRecording, caso a fonte j tenha determinado.
                    // Isso  essencial para webcam/videofile que podem demorar a reportar o tamanho.
                    if (UIVRWebcamFrameSource* WebcamSource = Cast<UIVRWebcamFrameSource>(CurrentFrameSource))
                    {
                        // Espera um pouco mais para a webcam reportar a resoluo real se ainda no o fez
                        for (int i = 0; i < 10; ++i) 
                        {
                            ActualFrameWidth = WebcamSource->GetActualFrameWidth();
                            ActualFrameHeight = WebcamSource->GetActualFrameHeight();
                            if (ActualFrameWidth > 0 && ActualFrameHeight > 0)
                            {
                                UE_LOG(LogIVR, Log, TEXT("UIVRCaptureComponent: Webcam actual resolution determined: %dx%d after %d retries."), ActualFrameWidth, ActualFrameHeight, i+1);
                                break;
                            }
                            FPlatformProcess::Sleep(0.01f);
                        }

                        if (ActualFrameWidth <= 0 || ActualFrameHeight <= 0)
                        {
                            // Fallback para as dimenses do VideoSettings se a webcam no reportar vlido
                            ActualFrameWidth = VideoSettings.Width;
                            ActualFrameHeight = VideoSettings.Height;
                            UE_LOG(LogIVR, Error, TEXT("UIVRCaptureComponent: Webcam reported invalid resolution (%dx%d) after polling. Using VideoSettings for recording."), ActualFrameWidth, ActualFrameHeight);
                        }
                    }
                    else if (UIVRVideoFrameSource* VideoFileSource = Cast<UIVRVideoFrameSource>(CurrentFrameSource))
                    {
                        // Espera um pouco mais para o arquivo de vdeo reportar a resoluo real
                        for (int i = 0; i < 10; ++i)
                        {
                            ActualFrameWidth = VideoFileSource->GetActualFrameWidth();
                            ActualFrameHeight = VideoFileSource->GetActualFrameHeight();
                            if (ActualFrameWidth > 0 && ActualFrameHeight > 0)
                            {
                                UE_LOG(LogIVR, Log, TEXT("UIVRCaptureComponent: VideoFile actual resolution determined: %dx%d after %d retries."), ActualFrameWidth, ActualFrameHeight, i+1);
                                break;
                            }
                            FPlatformProcess::Sleep(0.01f);
                        }

                        if (ActualFrameWidth <= 0 || ActualFrameHeight <= 0)
                        {
                            // Fallback para as dimenses do VideoSettings
                            ActualFrameWidth = VideoSettings.Width;
                            ActualFrameHeight = VideoSettings.Height;
                            UE_LOG(LogIVR, Error, TEXT("UIVRCaptureComponent: VideoFileSource reported invalid resolution (%dx%d) after polling. Using VideoSettings for recording."), ActualFrameWidth, ActualFrameHeight);
                        }
                    }
                    else // Para RenderTarget, Folder, Simulated, as dimenses j esto em VideoSettings
                    {
                        ActualFrameWidth = VideoSettings.Width;
                        ActualFrameHeight = VideoSettings.Height;
                    }

                    // Re-inicializa o FramePool com as dimenses reais obtidas
                    FramePool->Initialize(FramePoolSize, ActualFrameWidth, ActualFrameHeight, true); 
                    
                    if (!VideoSettings.bEnableRTFrames) 
                    {
                        StartNewTake(); 
                        if (!CurrentSession) 
                        {
                            UE_LOG(LogIVR, Error, TEXT("UIVRCaptureComponent: StartNewTake failed to create initial recording session. Aborting."));
                            bIsRecording = false;
                            CurrentFrameSource->StopCapture();
                            return;
                        }
                    }
                    else 
                    {
                        if (!RealTimeOutputTexture2D || RealTimeOutputTexture2D->GetSizeX() != ActualFrameWidth || RealTimeOutputTexture2D->GetSizeY() != ActualFrameHeight)
                        {
                            if (RealTimeOutputTexture2D)
                            {
                                RealTimeOutputTexture2D->ReleaseResource(); 
                                RealTimeOutputTexture2D = nullptr; 
                            }

                            RealTimeOutputTexture2D = UTexture2D::CreateTransient(ActualFrameWidth, ActualFrameHeight, PF_B8G8R8A8); 
                            if (RealTimeOutputTexture2D)
                            {
                                RealTimeOutputTexture2D->UpdateResource(); 
                                RealTimeOutputTexture2D->Filter = TF_Bilinear;
                                RealTimeOutputTexture2D->CompressionSettings = TC_EditorIcon; 
                                RealTimeOutputTexture2D->SRGB = true; 
                                UE_LOG(LogIVR, Log, TEXT("UIVRCaptureComponent: Real-Time Output Texture2D created/recreated: %dx%d."), ActualFrameWidth, ActualFrameHeight);
                            }
                            else
                            {
                                UE_LOG(LogIVR, Error, TEXT("UIVRCaptureComponent: Failed to create RealTimeOutputTexture2D. JustRTCapture will not function correctly."));
                                bIsRecording = false;
                                CurrentFrameSource->StopCapture();
                                return;
                            }
                        }
                        UE_LOG(LogIVR, Log, TEXT("UIVRCaptureComponent: JustRTCapture enabled. Frames will be sent via delegate."));
                    }
                    
                    OnRecordingStarted.Broadcast(); 
                    UE_LOG(LogIVR, Log, TEXT("UIVRCaptureComponent: Recording/Capture started. Actual Frame Size: %dx%d (used for FFmpeg and FramePool)"), ActualFrameWidth, ActualFrameHeight);
                }
                else 
                {
                    UE_LOG(LogIVR, Error, TEXT("UIVRCaptureComponent: Cannot start recording, CurrentFrameSource is null."));
                    bIsRecording = false;
                    return;
                }
            }
        });
}

void UIVRCaptureComponent::StopRecording()
{
    AsyncTask(ENamedThreads::GameThread, [this]()
        {
            if (bIsRecording)
            {
                if (!VideoSettings.bEnableRTFrames) 
                {
                    EndCurrentTake();
                    // Gerar o master aps todos os takes terem sido finalizados individualmente
                    UIVRRecordingManager::Get()->GenerateMasterVideoAndCleanup();
                }
                
                if (CurrentFrameSource)
                {
                    CurrentFrameSource->StopCapture();
                    UE_LOG(LogIVR, Log, TEXT("UIVRCaptureComponent: Frame source capture stopped."));
                }
                
                bIsRecording = false;
                OnRecordingStopped.Broadcast(); 
                UE_LOG(LogIVR, Log, TEXT("UIVRCaptureComponent: Recording stopped."));
            }
        });
}

void UIVRCaptureComponent::PauseTake()
{
    AsyncTask(ENamedThreads::GameThread, [this]()
        {
            if (bIsRecording && CurrentSession)
            {
                CurrentSession->PauseRecording();
                
                if (CurrentFrameSource)
                {
                    CurrentFrameSource->StopCapture(); 
                    UE_LOG(LogIVR, Log, TEXT("UIVRCaptureComponent: Frame source paused."));
                }
                OnRecordingPaused.Broadcast(); 
            }
        });
}

void UIVRCaptureComponent::ResumeTake()
{
    AsyncTask(ENamedThreads::GameThread, [this]()
        {
            if (bIsRecording && CurrentSession)
            {
                CurrentSession->ResumeRecording();

                if (CurrentFrameSource)
                {
                    CurrentFrameSource->StartCapture();
                    UE_LOG(LogIVR, Log, TEXT("UIVRCaptureComponent: Frame source resumed."));
                }
                OnRecordingResumed.Broadcast(); 
            }
        });
}

void UIVRCaptureComponent::StartNewTake()
{
    if (CurrentSession)
    {
        // Garante que o take anterior seja finalizado corretamente antes de iniciar um novo
        UIVRRecordingManager::Get()->StopRecording(CurrentSession);
        CurrentSession = nullptr; 
    }

    // Inicia uma nova sesso de gravao
    CurrentSession = UIVRRecordingManager::Get()->StartRecording(VideoSettings, ActualFrameWidth, ActualFrameHeight, FramePool);

    if (!CurrentSession)
    {
        UE_LOG(LogIVR, Error, TEXT("UIVRCaptureComponent: Failed to create new recording session for take %d. Aborting future takes."), CurrentTakeNumber + 1);
        bIsRecording = false; 
        CurrentFrameSource->StopCapture();
        return;
    }

    CurrentTakeTime = 0.0f;
    CurrentTakeNumber++;
    UE_LOG(LogIVR, Log, TEXT("UIVRCaptureComponent: Started take %d"), CurrentTakeNumber);
}

void UIVRCaptureComponent::EndCurrentTake()
{
    if (CurrentSession)
    {
        UIVRRecordingManager::Get()->StopRecording(CurrentSession);
        CurrentSession = nullptr;
        UE_LOG(LogIVR, Log, TEXT("UIVRCaptureComponent: Ended take %d"), CurrentTakeNumber);
    }
}

void UIVRCaptureComponent::OnFrameAcquiredFromSource(FIVR_VideoFrame Frame)
{
    UE_LOG(LogIVR, Warning, TEXT("UIVRCaptureComponent: Received frame from source. RawDataPtr size: %d"), 
        Frame.RawDataPtr.IsValid() ? Frame.RawDataPtr->Num() : 0);

    if (bIsRecording)
    {
        if (!VideoSettings.bEnableRTFrames) 
        {
            if (CurrentSession)
            {
                // Passa o frame para a sesso para codificao em arquivo
                CurrentSession->AddVideoFrame(Frame); 
                UE_LOG(LogIVR, Warning, TEXT("UIVRCaptureComponent: Passed frame to session. Current session producer queue count: %d"), CurrentSession->GetProducerQCounter());
            }
            else
            {
                UE_LOG(LogIVR, Warning, TEXT("UIVRCaptureComponent: Dropping frame - no recording session available."));
            }
        }
        else // Modo JustRTCapture (sada em tempo real)
        {
            FIVR_JustRTFrame FrameOutput; 
            FrameOutput.Width = Frame.Width;
            FrameOutput.Height = Frame.Height;
            FrameOutput.Timestamp = Frame.Timestamp;
            FrameOutput.SourceFrameTint = VideoSettings.IVR_FrameTint; // Passa a tintura original das configuraes
            if (Frame.RawDataPtr.IsValid())
            {
                FrameOutput.RawDataBuffer = *Frame.RawDataPtr; 

                // Aplica a cor de tintura do RealTimeDisplay (se no for branco puro)
                if (RTDisplayTint != FLinearColor::White)
                {
                    const int32 NumPixels = FrameOutput.Width * FrameOutput.Height;
                    // RawDataBuffer  BGRA
                    for (int32 i = 0; i < NumPixels; ++i)
                    {
                        // Blue
                        float B_float = (float)FrameOutput.RawDataBuffer[i * 4 + 0] / 255.0f;
                        B_float *= RTDisplayTint.B;
                        FrameOutput.RawDataBuffer[i * 4 + 0] = FMath::Clamp((uint8)(B_float * 255.0f), (uint8)0, (uint8)255);

                        // Green
                        float G_float = (float)FrameOutput.RawDataBuffer[i * 4 + 1] / 255.0f;
                        G_float *= RTDisplayTint.G;
                        FrameOutput.RawDataBuffer[i * 4 + 1] = FMath::Clamp((uint8)(G_float * 255.0f), (uint8)0, (uint8)255);

                        // Red
                        float R_float = (float)FrameOutput.RawDataBuffer[i * 4 + 2] / 255.0f;
                        R_float *= RTDisplayTint.R;
                        FrameOutput.RawDataBuffer[i * 4 + 2] = FMath::Clamp((uint8)(R_float * 255.0f), (uint8)0, (uint8)255);

                        // Alpha (aplica se a tintura tiver alpha < 1.0f, caso contrrio mantm o original ou o que for)
                        float A_float = (float)FrameOutput.RawDataBuffer[i * 4 + 3] / 255.0f;
                        A_float *= RTDisplayTint.A;
                        FrameOutput.RawDataBuffer[i * 4 + 3] = FMath::Clamp((uint8)(A_float * 255.0f), (uint8)0, (uint8)255);
                    }
                }
            }

            FrameOutput.LiveTexture = RealTimeOutputTexture2D;
            FrameOutput.DisplayTint = RTDisplayTint; // Passa a tintura usada na estrutura de sada tambm
            if (RealTimeOutputTexture2D && FrameOutput.RawDataBuffer.Num() > 0) 
            {
                UpdateTextureFromRawData(RealTimeOutputTexture2D, FrameOutput.RawDataBuffer, FrameOutput.Width, FrameOutput.Height);
            }
            else
            {
                UE_LOG(LogIVR, Warning, TEXT("UIVRCaptureComponent: RealTimeOutputTexture2D ou RawDataBuffer invlido para sada RT."));
            }

            OnRealTimeFrameReady.Broadcast(FrameOutput);
            UE_LOG(LogIVR, Warning, TEXT("UIVRCaptureComponent: JustRTCapture: Frame processado e delegate disparado."));
        }
    }
    else 
    {
        UE_LOG(LogIVR, Warning, TEXT("UIVRCaptureComponent: Descartando frame da fonte - no gravando ou no no modo de captura RT."));
    }
}

void UIVRCaptureComponent::UpdateTextureFromRawData(UTexture2D* Texture, const TArray<uint8>& RawData, int32 InWidth, int32 InHeight)
{
    if (!Texture || !Texture->IsValidLowLevelFast() || !Texture->GetResource())
    {
        UE_LOG(LogIVR, Error, TEXT("UpdateTextureFromRawData: Textura ou recurso RHI invlido na entrada."));
        return;
    }

    if (Texture->GetSizeX() != InWidth || Texture->GetSizeY() != InHeight)
    {
        UE_LOG(LogIVR, Error, TEXT("UpdateTextureFromRawData: Dimenses da textura (%dx%d) no correspondem s do frame (%dx%d). Frame descartado."),
               Texture->GetSizeX(), Texture->GetSizeY(), InWidth, InHeight);
        return;
    }

    if (RawData.Num() != InWidth * InHeight * sizeof(FColor))
    {
        UE_LOG(LogIVR, Error, TEXT("UpdateTextureFromRawData: RawData size mismatch! Actual: %d, Expected: %d. Frame discarded."), RawData.Num(), InWidth * InHeight * sizeof(FColor));
        return; 
    }

    UE_LOG(LogIVR, Warning, TEXT("UpdateTextureFromRawData: Preparing data for GPU update. RawData.Num(): %d"), RawData.Num());
    uint8* MipData = new uint8[RawData.Num()];
    FMemory::Memcpy(MipData, RawData.GetData(), RawData.Num());

    FUpdateTextureRegion2D Region(0, 0, 0, 0, InWidth, InHeight);

    ENQUEUE_RENDER_COMMAND(UpdateTextureFromRawDataCommand)(
        [Texture, Region, InWidth, MipData](FRHICommandListImmediate& RHICmdList)
        {
            if (Texture && Texture->GetResource())
            {
                Texture->UpdateTextureRegions(
                    0,                                   
                    1,                                   
                    &Region,                             
                    InWidth * sizeof(FColor),            
                    0,                                   
                    MipData,                             
                    [](uint8* InSrcData, const FUpdateTextureRegion2D* InRegions) 
                    {
                        delete[] InSrcData; 
                    }
                );
            }
            else
            {
                UE_LOG(LogIVR, Error, TEXT("UpdateTextureFromRawData: Texture or RHI resource became invalid on Render Thread. MipData will be leaked if not explicitly deleted here."));
                delete[] MipData; 
            }
        });

    UE_LOG(LogIVR, Warning, TEXT("UpdateTextureFromRawData: UpdateTextureRegions command enqueued."));
}

FString UIVRCaptureComponent::PrepareVideoForRecording(const FString& InSourceVideoPath, const FString& OutPreparedVideoPath, bool bOverwrite)
{
    IPlatformFile& PlatformFile = FPlatformFileManager::Get().GetPlatformFile();

    if (!PlatformFile.FileExists(*InSourceVideoPath))
    {
        UE_LOG(LogIVR, Error, TEXT("PrepareVideoForRecording: Source video file not found at: %s"), *InSourceVideoPath);
        return FString();
    }

    if (PlatformFile.FileExists(*OutPreparedVideoPath) && !bOverwrite)
    {
        UE_LOG(LogIVR, Log, TEXT("PrepareVideoForRecording: Prepared video already exists at: %s and overwrite is disabled. Using existing file."), *OutPreparedVideoPath);
        return OutPreparedVideoPath;
    }

    FString FFmpegPath = FPaths::Combine(FPaths::ProjectPluginsDir(), TEXT("IVR"), TEXT("ThirdParty"), TEXT("FFmpeg"), TEXT("Binaries"));
#if PLATFORM_WINDOWS
    FFmpegPath = FPaths::Combine(FFmpegPath, TEXT("Win64"), TEXT("ffmpeg.exe"));
#elif PLATFORM_LINUX
    FFmpegPath = FPaths::Combine(FFmpegPath, TEXT("Linux"), TEXT("ffmpeg"));
#elif PLATFORM_MAC
    FFmpegPath = FPaths::Combine(FFmpegPath, TEXT("Mac"), TEXT("ffmpeg"));
#else
    UE_LOG(LogIVR, Error, TEXT("PrepareVideoForRecording: FFmpeg executable path not defined for current platform!"));
    return FString();
#endif
    FPaths::NormalizeDirectoryName(FFmpegPath);

    if (!PlatformFile.FileExists(*FFmpegPath))
    {
        // CORREO: Argumento FFMpegPath adicionado ao UE_LOG
        UE_LOG(LogIVR, Error, TEXT("PrepareVideoForRecording: FFmpeg executable not found at: %s. Cannot transcode video."), *FFmpegPath);
        return FString();
    }

    FString FFmpegArguments = FString::Printf(
        TEXT("-y -i %s -c:v libx264 -preset medium -crf 23 -pix_fmt yuv420p -c:a aac -b:a 128k %s"),
        *InSourceVideoPath,
        *OutPreparedVideoPath
    );

    UE_LOG(LogIVR, Log, TEXT("PrepareVideoForRecording: Transcoding video. Executable: %s, Arguments: %s"), *FFmpegPath, *FFmpegArguments);

    if (!UIVRRecordingManager::Get()->LaunchFFmpegProcessBlocking(FFmpegPath, FFmpegArguments))
    {
        UE_LOG(LogIVR, Error, TEXT("PrepareVideoForRecording: Video transcoding failed for: %s"), *InSourceVideoPath);
        if (PlatformFile.FileExists(*OutPreparedVideoPath))
        {
            PlatformFile.DeleteFile(*OutPreparedVideoPath);
        }
        return FString();
    }

    UE_LOG(LogIVR, Log, TEXT("PrepareVideoForRecording: Video successfully transcoded to: %s"), *OutPreparedVideoPath);
    return OutPreparedVideoPath;
}

FString UIVRCaptureComponent::ExportVideoToCompatibleFormat(const FString& InSourceVideoPath, const FString& OutCompatibleVideoPath, bool bOverwrite, const FIVR_VideoSettings& EncodingSettings)
{
    IPlatformFile& PlatformFile = FPlatformFileManager::Get().GetPlatformFile();

    if (!PlatformFile.FileExists(*InSourceVideoPath))
    {
        UE_LOG(LogIVR, Error, TEXT("ExportVideoToCompatibleFormat: Source video file not found at: %s"), *InSourceVideoPath);
        return FString();
    }

    if (PlatformFile.FileExists(*OutCompatibleVideoPath) && !bOverwrite)
    {
        UE_LOG(LogIVR, Log, TEXT("ExportVideoToCompatibleFormat: Compatible video already exists at: %s and overwrite is disabled. Using existing file."), *OutCompatibleVideoPath);
        return OutCompatibleVideoPath;
    }

    FString FFmpegPath = FPaths::Combine(FPaths::ProjectPluginsDir(), TEXT("IVR"), TEXT("ThirdParty"), TEXT("FFmpeg"), TEXT("Binaries"));
#if PLATFORM_WINDOWS
    FFmpegPath = FPaths::Combine(FFmpegPath, TEXT("Win64"), TEXT("ffmpeg.exe"));
#elif PLATFORM_LINUX
    FFmpegPath = FPaths::Combine(FFmpegPath, TEXT("Linux"), TEXT("ffmpeg"));
#elif PLATFORM_MAC
    FFmpegPath = FPaths::Combine(FFmpegPath, TEXT("Mac"), TEXT("ffmpeg"));
#else
    UE_LOG(LogIVR, Error, TEXT("ExportVideoToCompatibleFormat: FFmpeg executable path not defined for current platform!"));
    return FString();
#endif
    FPaths::NormalizeDirectoryName(FFmpegPath);

    if (!PlatformFile.FileExists(*FFmpegPath))
    {
        // CORREO: Argumento FFMpegPath adicionado ao UE_LOG
        UE_LOG(LogIVR, Error, TEXT("ExportVideoToCompatibleFormat: FFmpeg executable not found at: %s. Cannot transcode video."), *FFmpegPath);
        return FString();
    }

    FString FFmpegArguments = FString::Printf(
        TEXT("-y -i %s -c:v %s -preset medium -crf 23 -pix_fmt %s -b:v %d -r %f -c:a aac -b:a 128k %s"),
        *InSourceVideoPath,             
        *EncodingSettings.Codec,        
        *EncodingSettings.PixelFormat,  
        EncodingSettings.Bitrate,       
        EncodingSettings.FPS,           
        *OutCompatibleVideoPath         
    );

    UE_LOG(LogIVR, Log, TEXT("ExportVideoToCompatibleFormat: Transcoding video. Executable: %s, Arguments: %s"), *FFmpegPath, *FFmpegArguments);

    if (!UIVRRecordingManager::Get()->LaunchFFmpegProcessBlocking(FFmpegPath, FFmpegArguments))
    {
        UE_LOG(LogIVR, Error, TEXT("ExportVideoToCompatibleFormat: Video transcoding failed for: %s"), *InSourceVideoPath);
        if (PlatformFile.FileExists(*OutCompatibleVideoPath))
        {
            PlatformFile.DeleteFile(*OutCompatibleVideoPath);
        }
        return FString();
    }

    UE_LOG(LogIVR, Log, TEXT("ExportVideoToCompatibleFormat: Video successfully transcoded to: %s"), *OutCompatibleVideoPath);
    return OutCompatibleVideoPath;
}
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Components\IVRCaptureComponent.cpp ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Core\IVRFramePool.cpp ---
#include "Core/IVRFramePool.h"
#include "IVR.h" // Inclua a LogCategory (se n�o estiver em CoreMinimal)

DEFINE_LOG_CATEGORY(LogIVRFramePool);

UIVRFramePool::UIVRFramePool()
    : PoolSize(0)
    , FrameWidth(0)
    , FrameHeight(0)
    , FrameBufferSize(0)
{
    // O pool n�o � inicializado no construtor. Isso ser� feito em Initialize().
}

void UIVRFramePool::BeginDestroy()
{
    // Limpa o pool para liberar a mem�ria
    TSharedPtr<TArray<uint8>> DummyBuffer;
    while (FrameBufferPool.Dequeue(DummyBuffer))
    {
        // Buffers s�o liberados quando o TSharedPtr sai de escopo
    }
    Super::BeginDestroy();
}

void UIVRFramePool::Initialize(int32 InPoolSize, int32 InFrameWidth, int32 InFrameHeight, bool bForceReinitialize)
{
    if (bIsInitialized && !bForceReinitialize)
    {
        // Se j� inicializado e n�o for for�ado, verifica se os par�metros s�o os mesmos.
        if (PoolSize == InPoolSize && FrameWidth == InFrameWidth && FrameHeight == InFrameHeight)
        {
             UE_LOG(LogIVRFramePool, Log, TEXT("UIVRFramePool already initialized with same parameters (%dx%d). No-op."), FrameWidth, FrameHeight);
             return;
        }
        else
        {
             // Loga um aviso se tentar re-inicializar com par�metros diferentes sem for�ar.
             UE_LOG(LogIVRFramePool, Warning, TEXT("UIVRFramePool already initialized with different parameters (%dx%d vs %dx%d). Not re-initializing. Call Shutdown() or pass bForceReinitialize=true to override."),
                    FrameWidth, FrameHeight, InFrameWidth, InFrameHeight);
             return;
        }
    }

    // Se for for�ado ou n�o estiver inicializado, limpa o estado existente primeiro.
    if (bIsInitialized && bForceReinitialize)
    {
        TSharedPtr<TArray<uint8>> DummyBuffer;
        while (FrameBufferPool.Dequeue(DummyBuffer)) {} // Limpa buffers existentes
        UE_LOG(LogIVRFramePool, Log, TEXT("UIVRFramePool forced re-initialization: Cleared previous buffers."));
    }
    
    PoolSize = InPoolSize;
    FrameWidth = InFrameWidth;
    FrameHeight = InFrameHeight;
    FrameBufferSize = FrameWidth * FrameHeight * 4; // Assumindo 4 bytes por pixel (BGRA)

    if (FrameBufferSize <= 0)
    {
        UE_LOG(LogIVRFramePool, Error, TEXT("Invalid frame dimensions provided to UIVRFramePool::Initialize. Width: %d, Height: %d"), FrameWidth, FrameHeight);
        bIsInitialized = false; // Marca como n�o inicializado devido a erro
        return;
    }

    // Pr�-aloca os buffers no pool
    for (int32 i = 0; i < PoolSize; ++i)
    {
        TSharedPtr<TArray<uint8>> NewBuffer = MakeShared<TArray<uint8>>();
        NewBuffer->SetNumUninitialized(FrameBufferSize);
        FrameBufferPool.Enqueue(NewBuffer);
    }

    bIsInitialized = true;
    UE_LOG(LogIVRFramePool, Log, TEXT("UIVRFramePool initialized with %d buffers, each %d bytes (%dx%d)."), PoolSize, FrameBufferSize, FrameWidth, FrameHeight);
}

TSharedPtr<TArray<uint8>> UIVRFramePool::AcquireFrame()
{
    TSharedPtr<TArray<uint8>> PooledBuffer;

    if (!bIsInitialized)
    {
        UE_LOG(LogIVRFramePool, Error, TEXT("Attempted to acquire frame from uninitialized pool. Returning nullptr."));
        return nullptr;
    }

    // Tenta obter um buffer do pool.
    if (!FrameBufferPool.Dequeue(PooledBuffer))
    {
        // Se o pool estiver vazio, cria um novo buffer e loga um aviso.
        // Este buffer ter� o tamanho configurado no pool.
        UE_LOG(LogIVRFramePool, Warning, TEXT("FrameBufferPool exhausted! Creating new buffer (%d bytes). Consider increasing PoolSize."), FrameBufferSize);
        PooledBuffer = MakeShared<TArray<uint8>>();
        PooledBuffer->SetNumUninitialized(FrameBufferSize); // Garante o tamanho correto
    }
    // N�o precisa esvaziar/reservar novamente, SetNumUninitialized j� garante o tamanho e n�o precisa de dados anteriores.

    return PooledBuffer;
}

void UIVRFramePool::ReleaseFrame(TSharedPtr<TArray<uint8>> FrameBuffer)
{
    if (!FrameBuffer.IsValid())
    {
        UE_LOG(LogIVRFramePool, Warning, TEXT("Attempted to release an invalid (nullptr) frame buffer."));
        return;
    }
    if (!bIsInitialized)
    {
        UE_LOG(LogIVRFramePool, Error, TEXT("Attempted to release frame to uninitialized pool. Frame will not be reused."));
        return;
    }

    // N�o precisamos verificar o tamanho aqui, o pool aceita de volta.
    // O TArray<uint8> ser� automaticamente redimensionado se AcquireFrame criar um de tamanho diferente.
    // No entanto, � crucial que o AcquireFrame sempre retorne um buffer do tamanho correto.
    // Se um buffer de tamanho diferente for retornado ao pool, ele ser� armazenado e poder� ser reutilizado
    // incorretamente mais tarde se o AcquireFrame n�o garantir que ele tenha o FrameBufferSize correto.
    // A implementa��o atual de AcquireFrame (acima) j� garante que novos buffers t�m o tamanho certo.
    // Buffers retornados devem ser do tamanho esperado para evitar confus�o no pool.
    if (FrameBuffer->Num() != FrameBufferSize)
    {
        UE_LOG(LogIVRFramePool, Warning, TEXT("Released frame buffer has unexpected size (%d bytes) for a pool configured for %d bytes. Discarding frame to prevent issues."), FrameBuffer->Num(), FrameBufferSize);
        // N�o adiciona ao pool, pois � de tamanho incorreto. Ser� destru�do ao sair do escopo.
        return;
    }

    FrameBufferPool.Enqueue(FrameBuffer);
}
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Core\IVRFramePool.cpp ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Recording\IVRECFactory.cpp ---
// Fill out your copyright notice in the Description page of Project Settings.
#include "Recording/IVRECFactory.h" // Inclua o cabe�alho da sua pr�pria classe
#include "Internationalization/Text.h" // Para FText e FText::Format

// Defini��o do LogCategory (se j� definido em outro lugar, remova esta linha)
DEFINE_LOG_CATEGORY(LogIVRECFactory);

UIVRECFactory::UIVRECFactory()
{
    // Removido: Adi��o de formatos de comando padr�o para �udio.
}

void UIVRECFactory::IVR_AddCommandFormat(const FString& Name, const FString& Format)
{
    EncoderCommandFormats.Add(Name, Format);
}

void UIVRECFactory::IVR_BuildRawRgbCommand()
{
    // Constroi argumentos de forma individual para evitar problemas de sintaxe do Printf
    TArray<FString> ArgsArray;
    ArgsArray.Add(TEXT("-y")); // Sobrescreve o arquivo de sa�da sem perguntar

    // Entrada de V�deo RGBA    
    ArgsArray.Add(FString::Printf(TEXT("-f rawvideo -pix_fmt %s -s %dx%d -r %f"),*VideoSettings.PixelFormat, VideoSettings.Width, VideoSettings.Height, VideoSettings.FPS));
    
    //Informa Pipe de Entrada.
    ArgsArray.Add(FString::Printf(TEXT("-i %s"), *InVideoPipePath)); 
    
    // --- Mapeamento de Streams: Mudar para apenas mapear o v�deo (assumindo que � o primeiro e �nico input) ---
    ArgsArray.Add(TEXT("-map 0:v")); // Ou "-map 0:0" se preferir o �ndice da stream

    //=========================================TESTE 01===========================================
    ArgsArray.Add(TEXT("-vframes 300")); // Grava 300 frames (aprox. 10 segundos a 30 FPS)
    
    // Definir o formato de sa�da como rawvideo e o pixel format
    ArgsArray.Add(TEXT("-f rawvideo")); 
    ArgsArray.Add(FString::Printf(TEXT("-pix_fmt %s"),*VideoSettings.PixelFormat));
    //=========================================TESTE===========================================
    
    // Arquivo de saida
    ArgsArray.Add(*InOutputFilePath); 

    // Une todos os argumentos com um espa�o
    FString Arguments = FString::Join(ArgsArray, TEXT(" "));

    IVR_AddCommandFormat("RawRgbFrames", Arguments);
}

void UIVRECFactory::IVR_BuildLibx264Command()
{
    // Constroi argumentos de forma individual para evitar problemas de sintaxe do Printf
    TArray<FString> ArgsArray;
    ArgsArray.Add(TEXT("-y")); // Sobrescreve o arquivo de sa�da sem perguntar

    // Entrada de V�deo RGBA    
    // Entrada de V�deo RGBA - AGORA USANDO AS DIMENS�ES REAIS
    ArgsArray.Add(FString::Printf(TEXT("-f rawvideo -pix_fmt %s -s %dx%d -r %f"), *VideoSettings.PixelFormat, ActualVideoWidth, ActualVideoHeight, VideoSettings.FPS));
    
    //Informa Caminho do Pipe de Entrada.
    ArgsArray.Add(FString::Printf(TEXT("-i %s"), *InVideoPipePath)); 
    
    // --- Mapeamento de Streams: Mudar para apenas mapear o v�deo (assumindo que � o primeiro e �nico input) ---
    ArgsArray.Add(TEXT("-map 0:v")); // Apenas mapeia o v�deo, sem stream de �udio

    //=========================================TESTE 02===========================================
    ArgsArray.Add(TEXT("-c:v libx264"));      // Usar o encoder libx264
    ArgsArray.Add(TEXT("-preset ultrafast")); // Preset para velocidade (menos exigente)
    ArgsArray.Add(TEXT("-crf 23 "));           // Constant Rate Factor (controle de qualidade)
    //=========================================TESTE===========================================
    
    // Arquivo Saida
    ArgsArray.Add(*InOutputFilePath); 

    // Une todos os argumentos com um espa�o
    FString Arguments = FString::Join(ArgsArray, TEXT(" "));

    IVR_AddCommandFormat("libx264", Arguments);
}

void UIVRECFactory::IVR_BuildSettingsCommand()
{
    // Constroi argumentos de forma individual para evitar problemas de sintaxe do Printf
    TArray<FString> ArgsArray;
    ArgsArray.Add(TEXT("-y")); // Sobrescreve o arquivo de sa�da sem perguntar

    // Entrada de V�deo RGBA    
    ArgsArray.Add(FString::Printf(TEXT("-f rawvideo -pix_fmt %s -s %dx%d -r %f"), *VideoSettings.PixelFormat, ActualVideoWidth, ActualVideoHeight, VideoSettings.FPS));
    //Informa Caminho.
    ArgsArray.Add(FString::Printf(TEXT("-i %s"), *InVideoPipePath)); 
    
    // --- Mapeamento de Streams: Mudar para apenas mapear o v�deo (assumindo que � o primeiro e �nico input) ---
    ArgsArray.Add(TEXT("-map 0:v")); // Apenas mapeia o v�deo, sem stream de �udio

    // Sa�da de V�deo
    ArgsArray.Add(FString::Printf(TEXT("-c:v %s -b:v %d"), *VideoSettings.Codec, VideoSettings.Bitrate));
    
    // Arquivo de Sa�da
    ArgsArray.Add(*InOutputFilePath); 

    // Une todos os argumentos com um espa�o
    FString Arguments = FString::Join(ArgsArray, TEXT(" "));

    IVR_AddCommandFormat("UserSetRecSettings", Arguments);

}

void UIVRECFactory::IVR_BuildReadFrameCommand()
{
    //Comando Base: ffmpeg -f rawvideo -pix_fmt rgba -s 1920x1080 -r 30 -i \.\pipe\SeuNomeDoPipe -vframes 1 saida_frame_unico.png
    TArray<FString> ArgsArray;
    ArgsArray.Add(FString::FromInt(VideoSettings.Width));
    ArgsArray.Add(FString::FromInt(VideoSettings.Height));
    ArgsArray.Add(FString::SanitizeFloat(VideoSettings.FPS));
    ArgsArray.Add(ConsumerPipePath); // O caminho do pipe para o FFmpeg
    // Une todos os argumentos com um espa�o
    FString Arguments = FString::Join(ArgsArray, TEXT(" "));
}

void UIVRECFactory::IVR_BuildConcatenationCommand(const FString& InFilelistPath, const FString& InMasterOutputPath)
{
    TArray<FString> ArgsArray;
    ArgsArray.Add(TEXT("-y")); // Sobrescreve o arquivo de sa�da sem perguntar
    ArgsArray.Add(TEXT("-f concat")); // Usa o demuxer concat
    ArgsArray.Add(TEXT("-safe 0")); // Necess�rio para permitir caminhos absolutos no filelist.txt
    ArgsArray.Add(FString::Printf(TEXT("-i %s"), *InFilelistPath)); // Arquivo de lista de takes
    ArgsArray.Add(TEXT("-c copy")); // Copia os streams sem re-encode para maior velocidade e qualidade
    ArgsArray.Add(TEXT("-map 0:v")); // Explicitamente mapeia apenas o stream de v�deo para evitar problemas com �udio
    ArgsArray.Add(FString::Printf(TEXT(" %s"), *InMasterOutputPath)); // Arquivo de sa�da master

    FString Arguments = FString::Join(ArgsArray, TEXT(" "));
    IVR_AddCommandFormat("ConcatenateTakes", Arguments);
}


FString UIVRECFactory::IVR_GetEncoderCommand(const FString& CommandName)
{
    // Verifique se o formato de comando existe
    if (!EncoderCommandFormats.Contains(CommandName))
    {
        UE_LOG(LogIVRECFactory, Error, TEXT("Command format '%s' not found."), *CommandName);
        return FString();
    }

    FString FoundFormat = EncoderCommandFormats[CommandName];
    
    return FoundFormat;
}

void UIVRECFactory::IVR_SetPipeSettings()
{
    VideoPipeConfig.BasePipeName = TEXT("URVPipe");
    VideoPipeConfig.bBlockingMode = true;
    VideoPipeConfig.bDuplexAccess = false; 
    VideoPipeConfig.bMessageMode = false; 
}

FIVR_PipeSettings UIVRECFactory::IVR_GetPipeSettings()
{
    return VideoPipeConfig;
}

FIVR_VideoSettings UIVRECFactory::IVR_GetVideoSettings()
{
    return VideoSettings;
}

bool UIVRECFactory::IVR_GetExecFPath(FString& pIVR_ExecutablePath)
{
    // O caminho j� foi atribu�do corretamente no Initialize. Apenas verifique sua exist�ncia.
    if (!FPlatformFileManager::Get().GetPlatformFile().FileExists(*FFmpegExecutablePath))
    {
        UE_LOG(LogIVRECFactory, Error, TEXT("FFmpeg executable not found at: %s. Please ensure the path is correct."), *FFmpegExecutablePath);
        return false;
    }

    pIVR_ExecutablePath = FFmpegExecutablePath;
    return true;
}

FString UIVRECFactory::IVR_GetProducerPath()
{
    return ProducerPipePath;
}

FString UIVRECFactory::IVR_GetConsumerPath()
{
    return ConsumerPipePath;
}
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Recording\IVRECFactory.cpp ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Recording\IVRFolderFrameSource.cpp ---
#include "Recording/IVRFolderFrameSource.h"
#include "IVR.h"
#include "Engine/World.h"
#include "Misc/Paths.h"
#include "HAL/FileManager.h"

#if WITH_OPENCV
#include "OpenCVHelper.h"
#include "PreOpenCVHeaders.h"

#undef check // the check macro causes problems with opencv headers
#pragma warning(disable: 4668) // 'symbol' not defined as a preprocessor macro, replacing with '0' for 'directives'
#pragma warning(disable: 4828) // The character set in the source file does not support the character used in the literal
#include <opencv2/opencv.hpp>
#include <opencv2/videoio.hpp> // Para cv::VideoCapture
#include <opencv2/imgproc.hpp> // Para cv::cvtColor

#include "PostOpenCVHeaders.h"
#endif

// Adicione "ImageWrapper" ao Build.cs do seu m�dulo:
// PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "ImageWrapper" });

UIVRFolderFrameSource::UIVRFolderFrameSource()
    : UIVRFrameSource()
    , CurrentImageIndex(0)
{
}

void UIVRFolderFrameSource::Initialize(UWorld* World, const FIVR_VideoSettings& Settings, UIVRFramePool* InFramePool)
{
    if (!World || !InFramePool)
    {
        UE_LOG(LogIVRFrameSource, Error, TEXT("UIVRFolderFrameSource::Initialize: World or FramePool is null."));
        return;
    }
    CurrentWorld = World;
    FrameSourceSettings = Settings;
    FramePool = InFramePool;

    ImageFiles.Empty();
    CurrentImageIndex = 0;

    FString AbsoluteFolderPath = FPaths::Combine(FPaths::ProjectDir(), Settings.IVR_FramesFolder); // Assume caminho relativo ao projeto

    // Garante que o caminho � absoluto e normalize
    FPaths::NormalizeDirectoryName(AbsoluteFolderPath);
    
    if (!IFileManager::Get().DirectoryExists(*AbsoluteFolderPath))
    {
        UE_LOG(LogIVRFrameSource, Error, TEXT("UIVRFolderFrameSource: Folder '%s' does not exist!"), *AbsoluteFolderPath);
        return;
    }

    // Busca arquivos de imagem na pasta
    TArray<FString> FoundFiles;
    IFileManager::Get().FindFiles(FoundFiles, *AbsoluteFolderPath, TEXT("*.*"));

    // Filtra por extens�es de imagem suportadas
    TArray<FString> SupportedExtensions = { TEXT(".png"), TEXT(".jpg"), TEXT(".jpeg"), TEXT(".bmp"), TEXT(".tga"), TEXT(".exr") };
    for (const FString& File : FoundFiles)
    {
        FString Extension = FPaths::GetExtension(File, true).ToLower(); // GetExtension with dot
        if (SupportedExtensions.Contains(Extension))
        {
            ImageFiles.Add(FPaths::Combine(AbsoluteFolderPath, File));
        }
    }
    
    // Opcional: Ordenar os arquivos para garantir uma sequ�ncia correta
    ImageFiles.Sort();

    if (ImageFiles.Num() == 0)
    {
        UE_LOG(LogIVRFrameSource, Warning, TEXT("UIVRFolderFrameSource: No supported image files found in folder '%s'."), *AbsoluteFolderPath);
    }
    else
    {
        UE_LOG(LogIVRFrameSource, Log, TEXT("UIVRFolderFrameSource initialized with %d image files from '%s'."), ImageFiles.Num(), *AbsoluteFolderPath);
    }
}

void UIVRFolderFrameSource::Shutdown()
{
    StopCapture();
    ImageFiles.Empty();
    CurrentWorld = nullptr;
    FramePool = nullptr;
    UE_LOG(LogIVRFrameSource, Log, TEXT("UIVRFolderFrameSource Shutdown."));
}

void UIVRFolderFrameSource::StartCapture()
{
    if (!CurrentWorld) return;
    if (ImageFiles.Num() == 0)
    {
        UE_LOG(LogIVRFrameSource, Warning, TEXT("UIVRFolderFrameSource: Cannot start capture, no image files found."));
        return;
    }

    float Delay = (FrameSourceSettings.IVR_FolderPlaybackFPS > 0.0f) ? (1.0f / FrameSourceSettings.IVR_FolderPlaybackFPS) : (1.0f / 30.0f);
    CurrentWorld->GetTimerManager().SetTimer(FrameReadTimerHandle, this, &UIVRFolderFrameSource::ReadNextFrameFromFile, Delay, true);
    // Log atualizado para mostrar a dura��o por imagem
    UE_LOG(LogIVRFrameSource, Log, TEXT("UIVRFolderFrameSource: Starting frame reading from folder. Images will change every %.2f seconds (based on IVR_FolderPlaybackFPS of %.2f)."), Delay, FrameSourceSettings.IVR_FolderPlaybackFPS);
}

void UIVRFolderFrameSource::StopCapture()
{
    if (CurrentWorld && CurrentWorld->GetTimerManager().IsTimerActive(FrameReadTimerHandle))
    {
        CurrentWorld->GetTimerManager().ClearTimer(FrameReadTimerHandle);
    }
    FrameReadTimerHandle.Invalidate();
    UE_LOG(LogIVRFrameSource, Log, TEXT("UIVRFolderFrameSource: Stopped frame reading."));
}

void UIVRFolderFrameSource::ReadNextFrameFromFile()
{
    if (ImageFiles.Num() == 0)
    {
        StopCapture();
        UE_LOG(LogIVRFrameSource, Warning, TEXT("UIVRFolderFrameSource: No more image files to read. Stopping capture."));
        return;
    }

    // Gerencia o looping
    if (CurrentImageIndex >= ImageFiles.Num())
    {
        if (FrameSourceSettings.IVR_LoopFolderPlayback)
        {
            CurrentImageIndex = 0; // Reinicia o loop
            UE_LOG(LogIVRFrameSource, Log, TEXT("UIVRFolderFrameSource: Looping folder playback."));
        }
        else
        {
            StopCapture();
            UE_LOG(LogIVRFrameSource, Log, TEXT("UIVRFolderFrameSource: Folder playback finished (no looping)."));
            return;
        }
    }

    TSharedPtr<TArray<uint8>> FrameBuffer = AcquireFrameBufferFromPool();
    if (!FrameBuffer.IsValid())
    {
        UE_LOG(LogIVRFrameSource, Error, TEXT("Failed to acquire frame buffer from pool. Dropping folder frame."));
        CurrentImageIndex++; // Move para o pr�ximo mesmo se falhar a aquisi��o do buffer
        return;
    }

    // Carrega a imagem e decodifica para BGRA
    if (LoadImageFromFile(ImageFiles[CurrentImageIndex], *FrameBuffer))
    {
        FIVR_VideoFrame NewFrame(FrameSourceSettings.Width, FrameSourceSettings.Height, CurrentWorld->GetTimeSeconds());
        NewFrame.RawDataPtr = FrameBuffer;

        UE_LOG(LogIVRFrameSource, Warning, TEXT("UIVRFolderFrameSource: Read frame %d from '%s'."), CurrentImageIndex, *ImageFiles[CurrentImageIndex]);
        OnFrameAcquired.Broadcast(MoveTemp(NewFrame));
    }
    else
    {
        UE_LOG(LogIVRFrameSource, Error, TEXT("UIVRFolderFrameSource: Failed to load image from '%s'. Skipping frame."), *ImageFiles[CurrentImageIndex]);
        // Libera o buffer de volta para o pool se a carga falhar
        FramePool->ReleaseFrame(FrameBuffer);
    }

    CurrentImageIndex++;
}

bool UIVRFolderFrameSource::LoadImageFromFile(const FString& FilePath, TArray<uint8>& OutRawData)
{
    TArray<uint8> CompressedData;
    if (!FFileHelper::LoadFileToArray(CompressedData, *FilePath))
    {
        UE_LOG(LogIVRFrameSource, Error, TEXT("Failed to load image file to array: %s"), *FilePath);
        return false;
    }

    TSharedPtr<IImageWrapper> ImageWrapper = GetImageWrapperByExtention(FilePath);
    if (!ImageWrapper.IsValid())
    {
        UE_LOG(LogIVRFrameSource, Error, TEXT("Failed to create image wrapper for format: (%s)"), *FilePath);
        return false;
    }

    if (!ImageWrapper->SetCompressed(CompressedData.GetData(), CompressedData.Num()))
    {
        UE_LOG(LogIVRFrameSource, Error, TEXT("Failed to set compressed data or decompress image for: %s"), *FilePath);
        return false;
    }

    TArray<uint8> DecompressedData;
    ERGBFormat ImageFormatToUse = ERGBFormat::BGRA; // Prioriza BGRA

    // Tenta obter BGRA diretamente
    if (!ImageWrapper->GetRaw(ImageFormatToUse, 8, DecompressedData))
    {
        // Se BGRA falhou, tenta RGBA
        ImageFormatToUse = ERGBFormat::RGBA;
        if (!ImageWrapper->GetRaw(ImageFormatToUse, 8, DecompressedData))
        {
            // Se ambos falharam
            UE_LOG(LogIVRFrameSource, Error, TEXT("Failed to get raw image data (BGRA or RGBA) for: %s"), *FilePath);
            return false;
        }
    }

    // Se a descompress�o foi para RGBA, converte para BGRA
    if (ImageFormatToUse == ERGBFormat::RGBA)
    {
        const int32 NumPixels = ImageWrapper->GetWidth() * ImageWrapper->GetHeight();
        TArray<uint8> BGRATempData;
        BGRATempData.SetNumUninitialized(NumPixels * 4); // Alocar para a sa�da BGRA

        // Convers�o manual de RGBA para BGRA (trocar canais R e B)
        for (int32 i = 0; i < NumPixels; ++i)
        {
            BGRATempData[i * 4 + 0] = DecompressedData[i * 4 + 2]; // Blue (do R do RGBA)
            BGRATempData[i * 4 + 1] = DecompressedData[i * 4 + 1]; // Green
            BGRATempData[i * 4 + 2] = DecompressedData[i * 4 + 0]; // Red (do B do RGBA)
            BGRATempData[i * 4 + 3] = DecompressedData[i * 4 + 3]; // Alpha
        }
        DecompressedData = MoveTemp(BGRATempData); // Substitui os dados RGBA pelos BGRA
    }

#if WITH_OPENCV
    // Converter o TArray<uint8> para cv::Mat (tipo esperado pelo OpenCV)
    cv::Mat OriginalImageMat(ImageWrapper->GetHeight(), ImageWrapper->GetWidth(), CV_8UC4, DecompressedData.GetData());

    // Verificar se as dimens�es da imagem original correspondem �s dimens�es alvo
    if (OriginalImageMat.cols != FrameSourceSettings.Width || OriginalImageMat.rows != FrameSourceSettings.Height)
    {
        UE_LOG(LogIVRFrameSource, Warning, TEXT("Image dimensions (%dx%d) do not match target (%dx%d) for %s. Resizing..."),
            OriginalImageMat.cols, OriginalImageMat.rows, FrameSourceSettings.Width, FrameSourceSettings.Height, *FilePath);

        cv::Mat ResizedImageMat;
        cv::resize(OriginalImageMat, ResizedImageMat, cv::Size(FrameSourceSettings.Width, FrameSourceSettings.Height), 0, 0, cv::INTER_AREA);

        // Copiar os dados da cv::Mat redimensionada para OutRawData
        OutRawData.SetNumUninitialized(ResizedImageMat.total() * ResizedImageMat.elemSize());
        FMemory::Memcpy(OutRawData.GetData(), ResizedImageMat.data, ResizedImageMat.total() * ResizedImageMat.elemSize());
    }
    else
    {
        // Se as dimens�es j� correspondem, apenas move os dados descompactados para OutRawData
        OutRawData = MoveTemp(DecompressedData);
    }
#else
    // Se OpenCV n�o estiver habilitado, apenas move os dados descompactados (sem redimensionar)
    UE_LOG(LogIVRFrameSource, Warning, TEXT("OpenCV is not enabled. Image resizing for %s will be skipped."), *FilePath);
    OutRawData = MoveTemp(DecompressedData);
#endif

    return true; // Imagem carregada, convertida e redimensionada (se OpenCV ativo) com sucesso.
}

TSharedPtr<IImageWrapper> UIVRFolderFrameSource::GetImageWrapperByExtention(const FString InImagePath)
{
        IImageWrapperModule& ImageWrapperModule = FModuleManager::LoadModuleChecked<IImageWrapperModule>(FName("ImageWrapper"));
		if (InImagePath.EndsWith(".png"))
		{
			return ImageWrapperModule.CreateImageWrapper(EImageFormat::PNG);
		}
		else if (InImagePath.EndsWith(".jpg") || InImagePath.EndsWith(".jpeg"))
		{
			return ImageWrapperModule.CreateImageWrapper(EImageFormat::JPEG);
		}
		else if (InImagePath.EndsWith(".bmp"))
		{
			return ImageWrapperModule.CreateImageWrapper(EImageFormat::BMP);
		}
		else if (InImagePath.EndsWith(".ico"))
		{
			return ImageWrapperModule.CreateImageWrapper(EImageFormat::ICO);
		}
		else if (InImagePath.EndsWith(".exr"))
		{
			return ImageWrapperModule.CreateImageWrapper(EImageFormat::EXR);
		}
		else if (InImagePath.EndsWith(".icns"))
		{
			return ImageWrapperModule.CreateImageWrapper(EImageFormat::ICNS);
		}

		return nullptr;
}

--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Recording\IVRFolderFrameSource.cpp ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Recording\IVRFrameSource.cpp ---
#include "Recording/IVRFrameSource.h"
#include "IVR.h" // Inclua a LogCategory

DEFINE_LOG_CATEGORY(LogIVRFrameSource);

UIVRFrameSource::UIVRFrameSource()
{
}

void UIVRFrameSource::BeginDestroy()
{
    Shutdown(); // Garante que a fonte seja desligada ao ser destru�da
    Super::BeginDestroy();
}

TSharedPtr<TArray<uint8>> UIVRFrameSource::AcquireFrameBufferFromPool()
{
    if (!FramePool)
    {
        UE_LOG(LogIVRFrameSource, Error, TEXT("FramePool is invalid. Cannot acquire frame buffer."));
        return nullptr;
    }
    return FramePool->AcquireFrame();
}
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Recording\IVRFrameSource.cpp ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Recording\IVRRecordingManager.cpp ---
#include "Recording/IVRRecordingManager.h"
#include "Recording/IVRRecordingSession.h"
#include "Recording/IVRVideoEncoder.h" 
// REMOVIDO: #include "Audio/IVRAudioCaptureSystem.h" 
#include "Misc/Paths.h" 
#include "Misc/DateTime.h" 
#include "Misc/FileHelper.h"
#include "HAL/PlatformProcess.h"
#include "HAL/FileManager.h"
#include "HAL/PlatformFileManager.h" 
#include "IVR.h" 
#include "Core/IVRFramePool.h" 

// Inicializa��o do Singleton Instance
UIVRRecordingManager* UIVRRecordingManager::Instance = nullptr;

UIVRRecordingManager* UIVRRecordingManager::Get()
{
    if (!Instance)
    {
        Instance = NewObject<UIVRRecordingManager>();
        Instance->AddToRoot(); // Impede o Garbage Collection de destruir o singleton
        Instance->Initialize();
    }
    return Instance;
}

void UIVRRecordingManager::Initialize()
{
    // REMOVIDO: AudioCapture = NewObject<UIVRAudioCaptureSystem>(this); 
    UtilityVideoEncoder = NewObject<UIVRVideoEncoder>(this); // Cria uma inst�ncia para uso geral (ex: concatena��o)
    UE_LOG(LogIVR, Log, TEXT("IVR Recording Manager initialized"));
}

void UIVRRecordingManager::Cleanup()
{
    // Limpa todas as sess�es ativas no momento do Cleanup
    for (int32 i = ActiveSessions.Num() - 1; i >= 0; --i)
    {
        if (ActiveSessions[i])
        {
            StopRecording(ActiveSessions[i]); // Chamar StopRecording para cada sess�o
        }
    }
    ActiveSessions.Empty(); 
    
    // REMOVIDO: AudioCapture = nullptr; 

    if (UtilityVideoEncoder)
    {
        UtilityVideoEncoder->ShutdownEncoder(); // Garante que o encoder de utilidade seja desligado
        UtilityVideoEncoder = nullptr;
    }
    
    if (Instance == this) 
    {
        RemoveFromRoot(); 
        Instance = nullptr;
    }

    UE_LOG(LogIVR, Log, TEXT("IVR Recording Manager cleaned up"));
}

UIVRRecordingSession* UIVRRecordingManager::StartRecording(const FIVR_VideoSettings& VideoSettings, int32 ActualFrameWidth, int32 ActualFrameHeight, UIVRFramePool* InFramePool)
{
    UIVRRecordingSession* NewSession = NewObject<UIVRRecordingSession>(this);
    if (!NewSession)
    {
        UE_LOG(LogIVR, Error, TEXT("Failed to create new IVRRecordingSession."));
        return nullptr;
    }

    FString FFmpegPath = FPaths::Combine(FPaths::ProjectPluginsDir(), TEXT("IVR"), TEXT("ThirdParty"), TEXT("FFmpeg"), TEXT("Binaries"));
#if PLATFORM_WINDOWS
    FFmpegPath = FPaths::Combine(FFmpegPath, TEXT("Win64"), TEXT("ffmpeg.exe"));
#elif PLATFORM_LINUX
    FFmpegPath = FPaths::Combine(FFmpegPath, TEXT("Linux"), TEXT("ffmpeg"));
#elif PLATFORM_MAC
    FFmpegPath = FPaths::Combine(FFmpegPath, TEXT("Mac"), TEXT("ffmpeg"));
#else
    UE_LOG(LogIVR, Warning, TEXT("FFmpeg path not defined for current platform. Using default path."));
    FFmpegPath = FPaths::Combine(FFmpegPath, TEXT("Unsupported"), TEXT("ffmpeg")); 
#endif
    FPaths::NormalizeDirectoryName(FFmpegPath); 

    NewSession->Initialize(VideoSettings, FFmpegPath, ActualFrameWidth, ActualFrameHeight, InFramePool); 
    NewSession->StartRecording(); 
    
    ActiveSessions.Add(NewSession);
    
    UE_LOG(LogIVR, Log, TEXT("Started new recording session. FFmpeg path: %s"), *FFmpegPath);
    return NewSession;
}

void UIVRRecordingManager::StopRecording(UIVRRecordingSession* Session)
{
    if (!Session)
        return;

    Session->StopRecording(); 
    
    FString SessionOutputPath = Session->GetOutputPath();
    if (!SessionOutputPath.IsEmpty() && FPlatformFileManager::Get().GetPlatformFile().FileExists(*SessionOutputPath))
    {
        FIVR_TakeInfo TakeInfo;
        TakeInfo.TakeNumber = CompletedTakes.Num() + 1;
        TakeInfo.Duration = Session->GetDuration(); 
        TakeInfo.StartTime = Session->GetStartTime(); 
        TakeInfo.EndTime = FDateTime::Now(); 
        TakeInfo.FilePath = SessionOutputPath; 
        TakeInfo.SessionID = Session->GetSessionID(); 
        
        CompletedTakes.Add(TakeInfo);
        UE_LOG(LogIVR, Log, TEXT("Take %d completed and added to list. File: %s"), TakeInfo.TakeNumber, *TakeInfo.FilePath);
    }
    else
    {
        UE_LOG(LogIVR, Warning, TEXT("Take completed, but file not found or path invalid: %s. Not added to CompletedTakes list."), *SessionOutputPath);
    }

    ActiveSessions.Remove(Session);
}

void UIVRRecordingManager::FinalizeAllRecordings(FString MasterVideoPath, const FIVR_VideoSettings& VideoSettings, const FString& FFmpegExecutablePath)
{
    if (CompletedTakes.Num() == 0)
    {
        UE_LOG(LogIVR, Warning, TEXT("No completed takes to finalize into a master video."));
        return;
    }

    if (!UtilityVideoEncoder)
    {
        UE_LOG(LogIVR, Error, TEXT("UtilityVideoEncoder is null. Cannot finalize recordings."));
        return;
    }

    if (!UtilityVideoEncoder->IsInitialized())
    {
        if (!UtilityVideoEncoder->Initialize(VideoSettings, FFmpegExecutablePath, VideoSettings.Width, VideoSettings.Height, nullptr)) 
        {
            UE_LOG(LogIVR, Error, TEXT("Failed to initialize UtilityVideoEncoder for concatenation."));
            return;
        }
    }

    TArray<FString> TakeFilePaths;
    for (const FIVR_TakeInfo& Take : CompletedTakes)
    {
        TakeFilePaths.Add(Take.FilePath);
    }

    UE_LOG(LogIVR, Log, TEXT("Starting master video concatenation of %d takes to: %s"), TakeFilePaths.Num(), *MasterVideoPath);
    if (UtilityVideoEncoder->ConcatenateVideos(TakeFilePaths, MasterVideoPath))
    {
        UE_LOG(LogIVR, Log, TEXT("Master video successfully created at: %s"), *MasterVideoPath);
        ClearAllTakes(); 
    }
    else
    {
        UE_LOG(LogIVR, Error, TEXT("Failed to create master video at: %s"), *MasterVideoPath);
    }

    UtilityVideoEncoder->ShutdownEncoder();
}

TArray<FIVR_TakeInfo> UIVRRecordingManager::GetAllTakes() const
{
    return CompletedTakes;
}

void UIVRRecordingManager::ClearAllTakes()
{
    CompletedTakes.Empty();
    UE_LOG(LogIVR, Log, TEXT("Cleared all takes"));
}

FString UIVRRecordingManager::GenerateMasterVideoAndCleanup()
{
    if (CompletedTakes.Num() == 0)
    {
        UE_LOG(LogIVR, Warning, TEXT("No completed takes to generate master video."));
        return FString();
    }

    FString Timestamp = FDateTime::Now().ToString(TEXT("%Y%m%d_%H%M%S"));
    FString BaseDir = FPaths::ProjectSavedDir() / TEXT("Recordings"); 
    IPlatformFile& PlatformFile = FPlatformFileManager::Get().GetPlatformFile();

    if (!PlatformFile.DirectoryExists(*BaseDir))
    {
        PlatformFile.CreateDirectoryTree(*BaseDir);
    }
    
    FString CurrentSessionID = CompletedTakes.Num() > 0 ? CompletedTakes.Last().FilePath.Mid(CompletedTakes.Last().FilePath.Len() - 17, 5) : FGuid::NewGuid().ToString(EGuidFormats::Digits).Mid(0,5);
    MasterVideoFilePath = FString::Printf(TEXT("%s/%s_%s_Master.mp4"), *BaseDir, *Timestamp, *CurrentSessionID);
    FString ConcatListFilePath = FPaths::Combine(FPaths::ProjectSavedDir(), TEXT("Recordings"), FString::Printf(TEXT("concat_list_%s.txt"), *Timestamp));
    FString ConcatListContent;
    TArray<FString> TakeFilePaths;

    for (const FIVR_TakeInfo& Take : CompletedTakes)
    {
        ConcatListContent += FString::Printf(TEXT("file '%s'\n"), *Take.FilePath);
        TakeFilePaths.Add(Take.FilePath); 
    }

    if (!FFileHelper::SaveStringToFile(ConcatListContent, *ConcatListFilePath))
    {
        UE_LOG(LogIVR, Error, TEXT("Failed to save concat list file to: %s"), *ConcatListFilePath);
        return FString();
    }

    FString FFmpegPath = FPaths::Combine(FPaths::ProjectPluginsDir(), TEXT("IVR"), TEXT("ThirdParty"), TEXT("FFmpeg"), TEXT("Binaries"));
#if PLATFORM_WINDOWS
    FFmpegPath = FPaths::Combine(FFmpegPath, TEXT("Win64"), TEXT("ffmpeg.exe"));
#elif PLATFORM_LINUX
    FFmpegPath = FPaths::Combine(FFmpegPath, TEXT("Linux"), TEXT("ffmpeg"));
#elif PLATFORM_MAC
    FFmpegPath = FPaths::Combine(FFmpegPath, TEXT("Mac"), TEXT("ffmpeg"));
#else
    UE_LOG(LogIVR, Warning, TEXT("FFmpeg path not defined for current platform. Using default path."));
    FFmpegPath = FPaths::Combine(FFmpegPath, TEXT("Unsupported"), TEXT("ffmpeg"));
#endif
    FPaths::NormalizeDirectoryName(FFmpegPath);

    FString FFmpegArguments = FString::Printf(TEXT("-y -f concat -safe 0 -i %s -c copy -map 0:v %s"), *ConcatListFilePath, *MasterVideoFilePath); // Adicionado -map 0:v
    UE_LOG(LogIVR, Log, TEXT("Launching FFmpeg for concatenation. Executable: %s , Arguments: %s"), *FFmpegPath, *FFmpegArguments);

    if (!LaunchFFmpegProcessBlocking(FFmpegPath, FFmpegArguments))
    {
        UE_LOG(LogIVR, Error, TEXT("FFmpeg concatenation process failed."));
        IFileManager::Get().Delete(*ConcatListFilePath);
        return FString();
    }
    IFileManager::Get().Delete(*ConcatListFilePath);

    UE_LOG(LogIVR, Log, TEXT("Master video generated successfully: %s"), *MasterVideoFilePath);

    CleanupIndividualTakes();
    IFileManager::Get().Delete(*ConcatListFilePath);
    CompletedTakes.Empty(); 
    
    return MasterVideoFilePath;
}

// Implementa��o da fun��o LaunchFFmpegProcessBlocking (AGORA P�BLICA)
bool UIVRRecordingManager::LaunchFFmpegProcessBlocking(const FString& ExecPath, const FString& Arguments)
{
    FProcHandle ProcHandle = FPlatformProcess::CreateProc(
        *ExecPath,
        *Arguments,
        false,   // bLaunchDetached
        true,    // bLaunchHidden
        true,    // bLaunchReallyHidden
        nullptr, // OutProcessID
        -1,      // PriorityModifier
        nullptr, // OptionalWorkingDirectory
        nullptr, // StdOutPipeWrite
        nullptr  // StdErrPipeWrite
    );

    if (!ProcHandle.IsValid())
    {
        UE_LOG(LogIVR, Error, TEXT("Failed to launch FFmpeg concat process. Check path and arguments."));
        return false;
    }

    FPlatformProcess::WaitForProc(ProcHandle);
    int32 ReturnCode = -1;
    FPlatformProcess::GetProcReturnCode(ProcHandle, &ReturnCode);
    FPlatformProcess::CloseProc(ProcHandle);

    if (ReturnCode != 0)
    {
        UE_LOG(LogIVR, Error, TEXT("FFmpeg concat process exited with error code: %d"), ReturnCode);
        return false;
    }
    return true;
}

void UIVRRecordingManager::CleanupIndividualTakes()
{
    IFileManager& FileManager = IFileManager::Get();
    for (const FIVR_TakeInfo& Take : CompletedTakes)
    {
        if (FileManager.FileExists(*Take.FilePath))
        {
            if (FileManager.Delete(*Take.FilePath))
            {
                UE_LOG(LogIVR, Log, TEXT("Deleted individual take file: %s"), *Take.FilePath);
            }
            else
            {
                UE_LOG(LogIVR, Warning, TEXT("Failed to delete individual take file: %s"), *Take.FilePath);
            }
        }
    }
}
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Recording\IVRRecordingManager.cpp ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Recording\IVRRecordingSession.cpp ---
// Fill out your copyright notice in the Description page of Project Settings.
#include "Recording/IVRRecordingSession.h"
#include "IVR.h"
#include "Misc/DateTime.h"
#include "Misc/Paths.h"
#include "Misc/Guid.h"
#include "Misc/FileHelper.h"     
#include "HAL/PlatformProcess.h"
#include "HAL/PlatformTime.h"    
#include "HAL/PlatformFileManager.h"
#include "HAL/FileManager.h"
#include "Async/Async.h" 

// Implementa��o do LogCategory
DEFINE_LOG_CATEGORY(LogIVRRecSession);

UIVRRecordingSession::UIVRRecordingSession()
    : VideoEncoder(nullptr) 
    , RecordingThread(nullptr)
    , HasNewFrameEvent(FPlatformProcess::GetSynchEventFromPool(true)) 
    , FramePool(nullptr) // Inicializa o FramePool
{
}

UIVRRecordingSession::~UIVRRecordingSession()
{
    // Garante que a grava��o seja interrompida e os recursos liberados.
    // Apenas chame StopRecording se a sess�o estiver ativa, para evitar warnings desnecess�rios.
    if (bIsRecording || bIsPaused || RecordingThread != nullptr || (VideoEncoder != nullptr && VideoEncoder->IsInitialized()))
    {
        StopRecording(); 
    }
    
    if (HasNewFrameEvent)
    {
        FGenericPlatformProcess::ReturnSynchEventToPool(HasNewFrameEvent);
        HasNewFrameEvent = nullptr;
    }
}

void UIVRRecordingSession::Initialize(const FIVR_VideoSettings& InVideoSettings, const FString& InFFmpegExecutablePath, int32 InActualFrameWidth, int32 InActualFrameHeight, UIVRFramePool* InFramePool)
{
    UserRecordingSettings = InVideoSettings;
    
    FramePool = InFramePool;
    if (!FramePool) // Verifica se o FramePool � v�lido
    {
        UE_LOG(LogIVRRecSession, Error, TEXT("UIVRRecordingSession::Initialize: FramePool is null. Cannot initialize."));
        return;
    }

    // Garante que o VideoEncoder seja inicializado uma �nica vez para esta sess�o/take.
    if (!VideoEncoder)
    {
        VideoEncoder = NewObject<UIVRVideoEncoder>(this);
        if (!VideoEncoder)
        {
            UE_LOG(LogIVRRecSession, Error, TEXT("Failed to create UIVRVideoEncoder instance."));
            return;
        }

        // Inicializa o VideoEncoder com as configura��es, o caminho do FFmpeg e a resolu��o real e o FramePool.
        if (!VideoEncoder->Initialize(UserRecordingSettings, InFFmpegExecutablePath, InActualFrameWidth, InActualFrameHeight, FramePool)) 
        {
            UE_LOG(LogIVRRecSession, Error, TEXT("Failed to initialize UIVRVideoEncoder."));
            VideoEncoder = nullptr; 
            return;
        }
    }
    
    SessionID = FGuid::NewGuid().ToString(EGuidFormats::Digits).Mid(0,5);
    CurrentTakeFilePath.Empty(); // Limpa o caminho do take anterior, se houver.
    
     UE_LOG(LogIVRRecSession, Log, TEXT("IVR Recording Session Initialized. FFmpeg Path: %s. Actual Frame Size: %dx%d"), *InFFmpegExecutablePath, InActualFrameWidth, InActualFrameHeight);
}

bool UIVRRecordingSession::StartRecording()
{
    if (bIsRecording || bIsPaused)
    {
        UE_LOG(LogIVRRecSession, Warning, TEXT("Recording is already in progress. Call StopRecording() first."));
        return false;
    }

    if (!VideoEncoder || !VideoEncoder->IsInitialized())
    {
        UE_LOG(LogIVRRecSession, Error, TEXT("VideoEncoder is not initialized. Cannot start recording."));
        return false;
    }

    bIsRecording.AtomicSet(true);
    bIsPaused.AtomicSet(false);
    bStopThread.AtomicSet(false);
    StartTime = FDateTime::Now();

    ClearQueues(); // Limpa as filas de frames
    
    // Gera o caminho completo para o take atual.
    CurrentTakeFilePath = GenerateTakeFilePath(); 

    // Lan�a o processo FFmpeg atrav�s do VideoEncoder.
    // Passa o caminho do take atual para o encoder.
    if (!VideoEncoder->LaunchEncoder(CurrentTakeFilePath))
    {
        UE_LOG(LogIVRRecSession, Error, TEXT("Failed to launch FFmpeg process via VideoEncoder. Aborting recording."));
        bIsRecording.AtomicSet(false);
        if (VideoEncoder && VideoEncoder->IsInitialized()) 
        {
            VideoEncoder->ShutdownEncoder();
        }
        return false;
    }

    // Inicia o thread de grava��o local (que apenas enfileira frames no VideoEncoder)
    RecordingThread = FRunnableThread::Create(this, TEXT("IVRecThread"), 0, TPri_Normal);
    if (!RecordingThread)
    {
        UE_LOG(LogIVRRecSession, Error, TEXT("Failed to create recording thread."));
        if (VideoEncoder && VideoEncoder->IsInitialized()) 
        {
            VideoEncoder->ShutdownEncoder(); 
        }
        bIsRecording.AtomicSet(false);
        return false;
    }

    UE_LOG(LogIVRRecSession, Log, TEXT("FFmpeg recording session started for take: %s"), *CurrentTakeFilePath);
    return true; 
}

void UIVRRecordingSession::StopRecording()
{
    // Valida��o robusta para evitar warnings falsos ou tentar parar algo que j� est� parado.
    bool bNeedsStopping = bIsRecording || bIsPaused || RecordingThread != nullptr || (VideoEncoder != nullptr && VideoEncoder->IsInitialized());

    if (!bNeedsStopping)
    {
        UE_LOG(LogIVRRecSession, Warning, TEXT("Attempted to stop recording, but session is not active or already stopped. No actions taken."));
        return;
    }

    UE_LOG(LogIVRRecSession, Log, TEXT("Stopping IVR Recording Session for take..."));

    bIsRecording.AtomicSet(false);
    bIsPaused.AtomicSet(false);
    bStopThread.AtomicSet(true); 

    if (HasNewFrameEvent)
    {
        HasNewFrameEvent->Trigger();
    }

    // Primeiro, sinaliza ao VideoEncoder que n�o haver� mais frames para grava��o do take atual.
    if (VideoEncoder && VideoEncoder->IsInitialized())
    {
        VideoEncoder->FinishEncoding();
    }

    // Espera o thread de grava��o local terminar
    if (RecordingThread)
    {
        UE_LOG(LogIVRRecSession, Log, TEXT("Waiting for recording thread to complete..."));
        RecordingThread->WaitForCompletion(); 
        delete RecordingThread;
        RecordingThread = nullptr;
        UE_LOG(LogIVRRecSession, Log, TEXT("Recording thread stopped."));
    }

    // Agora, desliga o processo principal do FFmpeg atrav�s do VideoEncoder.
    if (VideoEncoder && VideoEncoder->IsInitialized())
    {
        VideoEncoder->ShutdownEncoder();
    }

    // Calcula a dura��o final da grava��o
    RecordingDuration = (FDateTime::Now() - StartTime).GetTotalSeconds();
    UE_LOG(LogIVRRecSession, Log, TEXT("Take recording stopped. Final duration: %.2f seconds. File intended for: %s"), RecordingDuration, *CurrentTakeFilePath);
    
    // A valida��o se o arquivo foi realmente criado ser� feita pelo UIVRRecordingManager.
    // NENHUMA L�GICA DE CONCATENA��O AQUI.
}

void UIVRRecordingSession::PauseRecording()
{
    if (bIsRecording && !bIsPaused)
    {
        bIsPaused.AtomicSet(true);
        UE_LOG(LogIVRRecSession, Log, TEXT("Recording session paused for take: %s"), *SessionID);
    }
}

void UIVRRecordingSession::ResumeRecording()
{
    if (bIsRecording && bIsPaused)
    {
        bIsPaused.AtomicSet(false);
        UE_LOG(LogIVRRecSession, Log, TEXT("Recording session resumed for take: %s"), *SessionID);
    }
}

float UIVRRecordingSession::GetDuration() const
{
    if (bIsRecording && !bIsPaused)
    {
        return (FDateTime::Now() - StartTime).GetTotalSeconds();
    }
    return RecordingDuration;
}

void UIVRRecordingSession::ClearQueues()
{
    FIVR_VideoFrame DummyVideoFrame;
    while (VideoFrameProducerQueue.Dequeue(DummyVideoFrame)) {}

    VideoConsumerQCounter = 0;
    VideoProducerQCounter = 0;
}

// Adiciona um frame de v�deo � fila. Timestamp j� � o tempo global.
void UIVRRecordingSession::AddVideoFrame(FIVR_VideoFrame Frame) // Assinatura mudada
{
    if (!bIsRecording || bIsPaused) 
    {
        // Se n�o estiver gravando ou estiver pausado, libera o frame imediatamente.
        if (FramePool && Frame.RawDataPtr.IsValid())
        {
            FramePool->ReleaseFrame(Frame.RawDataPtr);
        }
        return;
    }

    // Use a taxa de quadros alvo para estimar um limite de buffer mais preciso
    int32 MaxBufferedFrames = (UserRecordingSettings.FPS > 0) ? FMath::CeilToInt(UserRecordingSettings.FPS * 1.0f) : 30; 
    if (VideoProducerQCounter >= MaxBufferedFrames) 
    {
        UE_LOG(LogIVRRecSession, Warning, TEXT("Video frame producer queue is full (%d frames, max %d). Dropping frame."), VideoProducerQCounter, MaxBufferedFrames);
        // Libera o frame para o pool se a fila estiver cheia.
        if (FramePool && Frame.RawDataPtr.IsValid())
        {
            FramePool->ReleaseFrame(Frame.RawDataPtr);
        }
        return; 
    }

    // LOG DE DEBUG: Confirma o tamanho do frame que est� sendo enfileirado
    UE_LOG(LogIVRRecSession, Warning, TEXT("UIVRRecordingSession: Enqueuing frame. RawDataPtr size: %d"), 
        Frame.RawDataPtr.IsValid() ? Frame.RawDataPtr->Num() : 0);

    // Enfileira o frame para a worker thread processar. Usa MoveTemp para mover o TSharedPtr eficientemente.
    VideoFrameProducerQueue.Enqueue(MoveTemp(Frame)); 
    VideoProducerQCounter++;

    if (HasNewFrameEvent)
    {
        HasNewFrameEvent->Trigger(); 
    }
}

FString UIVRRecordingSession::GenerateTakeFilePath()
{
    FString Timestamp = FDateTime::Now().ToString(TEXT("%Y%m%d_%H%M%S"));
    FString BaseDir = FPaths::ProjectSavedDir() / TEXT("Recordings"); 
    IPlatformFile& PlatformFile = FPlatformFileManager::Get().GetPlatformFile();

    if (!PlatformFile.DirectoryExists(*BaseDir))
    {
        PlatformFile.CreateDirectoryTree(*BaseDir);
    }
    
    FString NewTakePath = FString::Printf(TEXT("%s/%s_%s_Take.mp4"), *BaseDir, *Timestamp, *SessionID);
    UE_LOG(LogIVRRecSession, Log, TEXT("Generated take file: %s"), *NewTakePath);
    return NewTakePath;
}

FString UIVRRecordingSession::GenerateMasterFilePath() const
{
    FString Timestamp = FDateTime::Now().ToString(TEXT("%Y%m%d_%H%M%S"));
    FString BaseDir = FPaths::ProjectSavedDir() / TEXT("Recordings"); 
    IPlatformFile& PlatformFile = FPlatformFileManager::Get().GetPlatformFile();

    if (!PlatformFile.DirectoryExists(*BaseDir))
    {
        PlatformFile.CreateDirectoryTree(*BaseDir);
    }
    
    FString NewTakePath = FString::Printf(TEXT("%s/%s_%s_Master.mp4"), *BaseDir, *Timestamp, *SessionID);
    UE_LOG(LogIVRRecSession, Log, TEXT("Generated Master file: %s"), *NewTakePath);
    return NewTakePath;
}

// --- FRunnable implementation ---
bool UIVRRecordingSession::Init()
{
    UE_LOG(LogIVRRecSession, Log, TEXT("IVRecThread: Initialized."));
    return true;
}

uint32 UIVRRecordingSession::Run()
{
    
    FIVR_VideoFrame VideoFrame; // Onde o frame � dequeued
    
    while (!bStopThread)
    {
        // Tenta processar todos os frames na fila
        while (VideoFrameProducerQueue.Dequeue(VideoFrame))
        {
            VideoProducerQCounter--; 
            if (VideoEncoder)
            {
                // O VideoEncoder->EncodeFrame agora aceita a FIVR_VideoFrame completa
                // e acessa VideoFrame.RawDataPtr.
                VideoEncoder->EncodeFrame(VideoFrame); 
                VideoConsumerQCounter++; 
            }
            else
            {
                UE_LOG(LogIVRRecSession, Error, TEXT("IVRecThread: VideoEncoder is null. Dropping frame."));
            }
        }
        
        // Se a fila estiver vazia e o thread n�o for para parar, espera por um novo evento.
        if (VideoFrameProducerQueue.IsEmpty() && !bStopThread)
        {
            HasNewFrameEvent->Wait(100); // Espera por at� 100ms por um novo frame ou sinal de parada
        }
    }
    
    // Processa quaisquer frames remanescentes na fila antes de sair
    while (VideoFrameProducerQueue.Dequeue(VideoFrame))
    {
        VideoProducerQCounter--;
        if (VideoEncoder)
        {
            VideoEncoder->EncodeFrame(VideoFrame);
            VideoConsumerQCounter++;
        }
    }

    UE_LOG(LogIVRRecSession, Log, TEXT("IVRecThread: Run loop finished."));
    return 0;
}

void UIVRRecordingSession::Stop()
{
    UE_LOG(LogIVRRecSession, Log, TEXT("IVRecThread: Stop signal received."));
}

void UIVRRecordingSession::Exit()
{
    UE_LOG(LogIVRRecSession, Log, TEXT("IVRecThread: Exited."));
}
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Recording\IVRRecordingSession.cpp ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Recording\IVRRenderFrameSource.cpp ---
#include "Recording/IVRRenderFrameSource.h"
#include "IVR.h"
#include "HAL/PlatformMisc.h" 
#include "IVRGlobalStatics.h" 
#include "Async/Async.h" 

DEFINE_LOG_CATEGORY(LogIVRRenderFrameSource);

UIVRRenderFrameSource::UIVRRenderFrameSource()
    : UIVRFrameSource()
{
    bCanCaptureNextFrame.Set(1); // Inicializa como 1 (Unlocked), pronto para capturar
}

void UIVRRenderFrameSource::BeginDestroy()
{
    Shutdown(); // Garante que a fonte seja desligada ao ser destru�da
    UIVRFrameSource::BeginDestroy(); // Chama o BeginDestroy da classe base
}

// Implementa��o b�sica de Initialize (para casos onde o CaptureComponent n�o � passado)
void UIVRRenderFrameSource::Initialize(UWorld* World, const FIVR_VideoSettings& Settings, UIVRFramePool* InFramePool)
{
    // Este overload agora sempre chamar� o overload principal com um nullptr para VideoCaptureComponent.
    // A responsabilidade de fornecer um componente � unicamente do chamador (UIVRCaptureComponent).
    Initialize(World, Settings, InFramePool, nullptr);
}

// Overload de Initialize que aceita um USceneCaptureComponent2D existente
void UIVRRenderFrameSource::Initialize(UWorld* World, const FIVR_VideoSettings& Settings, UIVRFramePool* InFramePool, USceneCaptureComponent2D* InVideoCaptureComponent)
{
    if (!World || !InFramePool)
    {
        UE_LOG(LogIVRRenderFrameSource, Error, TEXT("UIVRRenderFrameSource::Initialize: World or FramePool is null. Cannot initialize."));
        return;
    }
    CurrentWorld = World;
    FrameSourceSettings = Settings;
    FramePool = InFramePool;

    // Inicializa��o do RenderTarget
    if (!VideoRenderTarget)
    {
        VideoRenderTarget = NewObject<UTextureRenderTarget2D>(this);
        if (VideoRenderTarget)
        {
            VideoRenderTarget->ClearColor = FLinearColor::Black;
            VideoRenderTarget->TargetGamma = 1.5f;
            VideoRenderTarget->RenderTargetFormat = ETextureRenderTargetFormat::RTF_RGBA8; // RGBA8 � RGBA
            VideoRenderTarget->InitAutoFormat(FrameSourceSettings.Width, FrameSourceSettings.Height);
            VideoRenderTarget->bGPUSharedFlag = true;
            VideoRenderTarget->UpdateResourceImmediate(true);
        }
    }
    else
    {
        VideoRenderTarget->ResizeTarget(FrameSourceSettings.Width, FrameSourceSettings.Height);
        VideoRenderTarget->UpdateResourceImmediate(true);
    }

    // Gerencia o VideoCaptureComponent: AGORA APENAS USA O QUE FOI PASSADO
    // A responsabilidade de criar e gerenciar o ciclo de vida do USceneCaptureComponent2D
    // � do UIVRCaptureComponent ou do usu�rio que o anexa.
    if (InVideoCaptureComponent)
    {
        VideoCaptureComponent = InVideoCaptureComponent;
        VideoCaptureComponent->TextureTarget = VideoRenderTarget; // Atribui o RenderTarget
        
        // Liga o delegate para o OnBackBufferReady
        if (FSlateApplication::IsInitialized() && FSlateApplication::Get().GetRenderer() && !OnBackBufferReadyToPresentHandle.IsValid())
        {
            OnBackBufferReadyToPresentHandle = FSlateApplication::Get().GetRenderer()->OnBackBufferReadyToPresent().AddUObject(this, &UIVRRenderFrameSource::OnBackBufferReady);
            UE_LOG(LogIVRRenderFrameSource, Log, TEXT("OnBackBufferReadyToPresent delegate BOUND."));
        }
        else if (OnBackBufferReadyToPresentHandle.IsValid())
        {
             // J� bound, talvez devido � re-inicializa��o sem shutdown completo
             UE_LOG(LogIVRRenderFrameSource, Warning, TEXT("OnBackBufferReadyToPresent delegate already bound. Skipping re-binding."));
        }
    }
    else
    {
        // Se nenhum componente de captura foi fornecido, loga um erro e n�o tenta capturar.
        VideoCaptureComponent = nullptr;
        UE_LOG(LogIVRRenderFrameSource, Error, TEXT("UIVRRenderFrameSource: No valid USceneCaptureComponent2D provided. Frame capture will not work."));
    }
    UE_LOG(LogIVRRenderFrameSource, Log, TEXT("UIVRRenderFrameSource initialized."));
}

void UIVRRenderFrameSource::Shutdown()
{
    StopCapture(); // Para a captura antes de desligar

    // N�o destru�mos VideoCaptureComponent aqui, pois ele � de propriedade externa (UIVRCaptureComponent)
    VideoCaptureComponent = nullptr; // Apenas limpa nossa refer�ncia

    if (VideoRenderTarget)
    {
        VideoRenderTarget->ReleaseResource();
        VideoRenderTarget = nullptr;
    }
    if (OnBackBufferReadyToPresentHandle.IsValid())
    {
        FSlateApplication::Get().GetRenderer()->OnBackBufferReadyToPresent().Remove(OnBackBufferReadyToPresentHandle);
        OnBackBufferReadyToPresentHandle.Reset();
        UE_LOG(LogIVRRenderFrameSource, Log, TEXT("OnBackBufferReadyToPresent delegate UNBOUND."));
    }
    
    // Limpa a fila de requests pendentes
    TSharedPtr<FRenderRequestInternal> DummyRequest;
    while(RenderRequestQueue.Dequeue(DummyRequest))
    {
        RReqQueueCounter--;
        // Buffers ser�o liberados quando o TSharedPtr sair de escopo
    }

    CurrentWorld = nullptr;
    FramePool = nullptr;
    UE_LOG(LogIVRRenderFrameSource, Log, TEXT("UIVRRenderFrameSource Shutdown."));
}

void UIVRRenderFrameSource::StartCapture()
{
    UE_LOG(LogIVRRenderFrameSource, Log, TEXT("UIVRRenderFrameSource: Starting capture."));
    bCanCaptureNextFrame.Set(1); // Libera para come�ar a capturar frames
}

void UIVRRenderFrameSource::StopCapture()
{
    UE_LOG(LogIVRRenderFrameSource, Log, TEXT("UIVRRenderFrameSource: Stopping capture."));
    bCanCaptureNextFrame.Set(0); // Bloqueia a captura de frames
}

// Esta fun��o � chamada na Render Thread
void UIVRRenderFrameSource::OnBackBufferReady(SWindow& SlateWindow, const FTextureRHIRef& BackBuffer)
{
    if (!IsInRenderingThread()) return; 

    AsyncTask(ENamedThreads::GameThread, [this]()
        {
            if (bCanCaptureNextFrame.GetValue() == 0 || !VideoRenderTarget || !VideoRenderTarget->GetResource())
            {
                return;
            }

            bCanCaptureNextFrame.Set(0);

            TSharedPtr<TArray<FColor>> AcquiredColorBuffer = MakeShared<TArray<FColor>>();
            AcquiredColorBuffer->SetNumUninitialized(FrameSourceSettings.Width * FrameSourceSettings.Height);
            TSharedPtr<FRenderRequestInternal> NewRenderRequest = MakeShared<FRenderRequestInternal>();
            NewRenderRequest->ImageBuffer = AcquiredColorBuffer; 

            struct FReadSurfaceContext
            {
                FRHITexture* Texture;
                TArray<FColor>* OutData;
                FIntRect Rect;
                FReadSurfaceDataFlags Flags;
            };

            FReadSurfaceContext ReadSurfaceContext = {
                VideoRenderTarget->GetResource()->GetTexture2DRHI(),
                NewRenderRequest->ImageBuffer.Get(), 
                FIntRect(0, 0, FrameSourceSettings.Width, FrameSourceSettings.Height),
                FReadSurfaceDataFlags(RCM_UNorm, CubeFace_MAX)
            };

            ENQUEUE_RENDER_COMMAND(ReadRenderTargetCommand)(
                [ReadSurfaceContext, NewRenderRequest](FRHICommandListImmediate& RHICmdList)
                {
                    RHICmdList.ReadSurfaceData(
                        ReadSurfaceContext.Texture,
                        ReadSurfaceContext.Rect,
                        *ReadSurfaceContext.OutData,
                        ReadSurfaceContext.Flags
                    );
                }
                );

            RenderRequestQueue.Enqueue(NewRenderRequest);
            RReqQueueCounter++;

            NewRenderRequest->RenderFence.BeginFence();

            UE_LOG(LogIVRRenderFrameSource, Warning, TEXT("Render request enqueued. Queue size: %d"), RReqQueueCounter);
        });
}

// Esta fun��o deve ser chamada na Game Thread (ex: do TickComponent do IVRCaptureComponent)
void UIVRRenderFrameSource::ProcessRenderQueue()
{
    if (!CurrentWorld || !FramePool) return;

    TSharedPtr<FRenderRequestInternal> CurrentRequest;
    if (RenderRequestQueue.Peek(CurrentRequest)) 
    {
        if (CurrentRequest->RenderFence.IsFenceComplete()) 
        {
            RenderRequestQueue.Dequeue(CurrentRequest); 
            RReqQueueCounter--;

            // Adquire o buffer do pool - Este � o TSharedPtr que gerenciaremos.
            TSharedPtr<TArray<uint8>> AcquiredByteBuffer = AcquireFrameBufferFromPool();
            if (!AcquiredByteBuffer.IsValid())
            {
                UE_LOG(LogIVRRenderFrameSource, Error , TEXT("Failed to acquire byte buffer from pool. Dropping processed render frame."));
                bCanCaptureNextFrame.Set(1); 
                return;
            }

            ConvertRgbaToBgraAndCopyToBuffer(*CurrentRequest->ImageBuffer, *AcquiredByteBuffer);

            // Cria o FIVR_VideoFrame. Ele agora cont�m uma c�pia do TSharedPtr AcquiredByteBuffer.
            FIVR_VideoFrame NewFrame(FrameSourceSettings.Width, FrameSourceSettings.Height, CurrentWorld->GetTimeSeconds());
            NewFrame.RawDataPtr = AcquiredByteBuffer; 

            // Faz o broadcast. Isso cria uma C�PIA do TSharedPtr RawDataPtr para o delegate.
            // A TSharedPtr original (AcquiredByteBuffer) e a TSharedPtr dentro de NewFrame.RawDataPtr
            // mant�m suas refer�ncias fortes.
            OnFrameAcquired.Broadcast(NewFrame); 

            // IMPORTANTE: Agora, NewFrame.RawDataPtr precisa liberar sua refer�ncia forte.
            // Isso garante que quando AcquiredByteBuffer for devolvido ao pool,
            // ele ser� a �nica refer�ncia forte restante (assumindo que o delegate n�o est� retendo-o de forma inesperada).
            NewFrame.RawDataPtr.Reset(); // Isso decrementa o ref count da TArray<uint8>

            // Agora, devolva o TSharedPtr original (AcquiredByteBuffer) ao pool.
            // Se NewFrame.RawDataPtr.Reset() fez o trabalho, o ref count de AcquiredByteBuffer deve ser 1.
            FramePool->ReleaseFrame(AcquiredByteBuffer); 

            UE_LOG(LogIVRRenderFrameSource, Warning , TEXT("Render frame processed and broadcasted. Remaining queue size: %d"), RReqQueueCounter);

            bCanCaptureNextFrame.Set(1); 
        }
    }
}


void UIVRRenderFrameSource::ConvertRgbaToBgraAndCopyToBuffer(const TArray<FColor>& InColors, TArray<uint8>& OutBuffer)
{
    const int32 NumPixels = InColors.Num();
    OutBuffer.SetNumUninitialized(NumPixels * 4); 

    for (int32 i = 0; i < NumPixels; ++i)
    {
        const FColor& Color = InColors[i];
        OutBuffer[i * 4 + 0] = Color.B; 
        OutBuffer[i * 4 + 1] = Color.G; 
        OutBuffer[i * 4 + 2] = Color.R; 
        OutBuffer[i * 4 + 3] = Color.A; 
    }
}
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Recording\IVRRenderFrameSource.cpp ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Recording\IVRSimulatedFrameSource.cpp ---
// IVRSimulatedFrameSource.cpp

#include "Recording/IVRSimulatedFrameSource.h"
#include "HAL/PlatformTime.h" // Para FPlatformTime::Seconds()
#include "Engine/World.h"     // Para GetWorldTimerManager()

UIVRSimulatedFrameSource::UIVRSimulatedFrameSource()
    : UIVRFrameSource() // Chama o construtor da base
{
}

void UIVRSimulatedFrameSource::BeginDestroy()
{
    UIVRFrameSource::BeginDestroy(); // Chama o BeginDestroy da base
}

// Implementa��o base
void UIVRSimulatedFrameSource::Initialize(UWorld* World, const FIVR_VideoSettings& Settings, UIVRFramePool* InFramePool)
{
    // Chama o overload com a tintura padr�o
    Initialize(World, Settings, InFramePool, FLinearColor::White);
}

// NOVO: Overload de Initialize com tintura
void UIVRSimulatedFrameSource::Initialize(UWorld* World, const FIVR_VideoSettings& Settings, UIVRFramePool* InFramePool, FLinearColor InFrameTint)
{
    if (!World || !InFramePool)
    {
        UE_LOG(LogIVRFrameSource, Error, TEXT("UIVRSimulatedFrameSource::Initialize: World or FramePool is null. Cannot initialize."));
        return;
    }
    CurrentWorld         = World;
    FrameSourceSettings  = Settings; // Armazena as configura��es
    FramePool            = InFramePool;        // Armazena a refer�ncia ao pool

    FrameRate            = Settings.FPS;
    FrameWidth           = Settings.Width;
    FrameHeight          = Settings.Height;
    ElapsedTime          = 0.0f;
    FrameCount           = 0;
    FrameTint            = InFrameTint; // NOVO: Armazena a tintura
    IVR_UseRandomPattern = Settings.IVR_UseRandomPattern;

    UE_LOG(LogIVRFrameSource, Log, TEXT("Simulated Frame Source Initialized: %dx%d @ %.2f FPS, Tint: %s"), FrameWidth, FrameHeight, FrameRate, *FrameTint.ToString());
}

void UIVRSimulatedFrameSource::StartCapture()
{
    if (!CurrentWorld || !FramePool)
    {
        UE_LOG(LogIVRFrameSource, Error, TEXT("UIVRSimulatedFrameSource::StartCapture: Not initialized. Call Initialize() first."));
        return;
    }

    // Garante que qualquer timer anterior seja parado
    StopCapture();

    float Delay = (FrameRate > 0.0f) ? (1.0f / FrameRate) : 0.0333f; // Default para ~30 FPS se FPS for 0
    UE_LOG(LogIVRFrameSource, Log, TEXT("UIVRSimulatedFrameSource: Attempting to set timer for frame generation. Delay: %f"), Delay);
    
    // Inicia o timer que chamar GenerateSimulatedFrame repetidamente
    CurrentWorld->GetTimerManager().SetTimer(FrameGenerationTimerHandle, this, &UIVRSimulatedFrameSource::GenerateSimulatedFrame, Delay, true);
    
    UE_LOG(LogIVRFrameSource, Log, TEXT("Simulated Frame Source Started. Generating frames every %.4f seconds."), Delay);
}

void UIVRSimulatedFrameSource::StopCapture()
{
    if (CurrentWorld && CurrentWorld->GetTimerManager().IsTimerActive(FrameGenerationTimerHandle))
    {
        CurrentWorld->GetTimerManager().ClearTimer(FrameGenerationTimerHandle);
        UE_LOG(LogIVRFrameSource, Log, TEXT("Simulated Frame Source Stopped."));
    }
    FrameGenerationTimerHandle.Invalidate(); // Marca o handle como invlido
}

void UIVRSimulatedFrameSource::Shutdown()
{
    StopCapture(); // Garante que o timer seja parado
    CurrentWorld = nullptr;
    FramePool = nullptr;
    UE_LOG(LogIVRFrameSource, Log, TEXT("UIVRSimulatedFrameSource Shutdown."));
}


void UIVRSimulatedFrameSource::GenerateSimulatedFrame()
{
    if (!CurrentWorld || !FramePool) return; // World ou FramePool pode ter sido invalidado ou no inicializado

    ElapsedTime += CurrentWorld->GetDeltaSeconds();
    FrameCount++;

    // Adquire um buffer do pool
    TSharedPtr<TArray<uint8>> FrameBuffer = AcquireFrameBufferFromPool();
    if (!FrameBuffer.IsValid())
    {
        UE_LOG(LogIVRFrameSource, Error, TEXT("Failed to acquire frame buffer from pool. Dropping simulated frame."));
        return;
    }

    // Cria um novo FIVR_VideoFrame e preenche-o com o buffer adquirido
    FIVR_VideoFrame NewFrame(FrameWidth, FrameHeight, FPlatformTime::Seconds());
    NewFrame.RawDataPtr = FrameBuffer; // Atribui o buffer adquirido

    // Preenche o frame com dados simulados
    FillSimulatedFrame(NewFrame);

    UE_LOG(LogIVRFrameSource, Log, TEXT("UIVRSimulatedFrameSource: Broadcasting frame %lld. RawDataPtr size: %d"), 
        FrameCount, NewFrame.RawDataPtr.IsValid() ? NewFrame.RawDataPtr->Num() : 0);

    // Notifica os ouvintes com o novo frame
    OnFrameAcquired.Broadcast(MoveTemp(NewFrame)); // Usar MoveTemp para eficincia
}

void UIVRSimulatedFrameSource::FillSimulatedFrame(FIVR_VideoFrame& InFrame)
{
    const int32 NumPixels = InFrame.Width * InFrame.Height;
    const int32 NumBytes = NumPixels * 4; // BGRA
    uint8 R_base = (uint8)(0.0f);
    uint8 G_base = (uint8)(0.0f);
    uint8 B_base = (uint8)(0.0f);

    // Garante que RawDataPtr � v�lido e aloca o TArray<uint8> se necess�rio
    if (!InFrame.RawDataPtr.IsValid())
    {
        InFrame.RawDataPtr = MakeShared<TArray<uint8>>();
    }
    InFrame.RawDataPtr->SetNumUninitialized(NumBytes);

    // Gera um padro de cor que muda gradualmente com o tempo
    if (IVR_UseRandomPattern)
    {
        R_base = (uint8)(FMath::Sin(ElapsedTime * 0.5f) * 127.0f + 128.0f);
        G_base = (uint8)(FMath::Sin(ElapsedTime * 0.7f + PI / 2.0f) * 127.0f + 128.0f);
        B_base = (uint8)(FMath::Sin(ElapsedTime * 0.9f + PI) * 127.0f + 128.0f);
    }
    else
    {
        R_base = (uint8)(255.0f);
        G_base = (uint8)(255.0f);
        B_base = (uint8)(255.0f);
    }
    // Preenche o buffer com a cor gerada (formato BGRA), aplicando a tintura
    for (int32 i = 0; i < NumPixels; ++i)
    {
        // Aplica a tintura base da configura��o � cor gerada
        // Convertendo para float, aplicando a multiplica��o e convertendo de volta para uint8
        float B_float = (float)B_base / 255.0f * FrameTint.B;
        float G_float = (float)G_base / 255.0f * FrameTint.G;
        float R_float = (float)R_base / 255.0f * FrameTint.R;
        float A_float = 1.0f * FrameTint.A; // Assume alpha total (255) para a base

        (*InFrame.RawDataPtr)[i * 4 + 0] = FMath::Clamp((uint8)(B_float * 255.0f), (uint8)0, (uint8)255); // Blue
        (*InFrame.RawDataPtr)[i * 4 + 1] = FMath::Clamp((uint8)(G_float * 255.0f), (uint8)0, (uint8)255); // Green
        (*InFrame.RawDataPtr)[i * 4 + 2] = FMath::Clamp((uint8)(R_float * 255.0f), (uint8)0, (uint8)255); // Red
        (*InFrame.RawDataPtr)[i * 4 + 3] = FMath::Clamp((uint8)(A_float * 255.0f), (uint8)0, (uint8)255); // Alpha (opaco)
    }
}
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Recording\IVRSimulatedFrameSource.cpp ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Recording\IVRVideoEncoder.cpp ---
#include "Recording/IVRVideoEncoder.h"
#include "IVR.h"
#include "Misc/Guid.h"         // Para FGuid::NewGuid()
#include "HAL/PlatformProcess.h" // Para FPlatformProcess
#include "HAL/PlatformTime.h"    // Para FPlatformTime::Seconds()
#include "HAL/PlatformFileManager.h" // Para IPlatformFileManager
#include "Misc/FileHelper.h"     // Para FFileHelper
#include "Internationalization/Text.h" // Para FText e FText::Format
#include "Async/Async.h" // Para UE_LOG no thread
#include "Misc/Paths.h" // Para FPaths

// Defini��o do LogCategory
DEFINE_LOG_CATEGORY(LogIVRVideoEncoder);

// =====================================================================================
// FVideoEncoderWorker Implementation
// =====================================================================================
FVideoEncoderWorker::FVideoEncoderWorker(UIVRVideoEncoder* InEncoder, TQueue<FIVR_VideoFrame, EQueueMode::Mpsc>& InFrameQueue, FIVR_PipeWrapper& InVideoInputPipe, FThreadSafeBool& InStopFlag, FThreadSafeBool& InNoMoreFramesFlag, FEvent* InNewFrameEvent, UIVRFramePool* InFramePool) // NOVO
    : Encoder(InEncoder)
    , FrameQueue(InFrameQueue)
    , VideoInputPipe(InVideoInputPipe)
    , bShouldStop(InStopFlag) 
    , bNoMoreFramesToEncode(InNoMoreFramesFlag)
    , NewFrameEvent(InNewFrameEvent)
    , FramePool(InFramePool) 
{
}

FVideoEncoderWorker::~FVideoEncoderWorker()
{
    // Limpeza aqui � m�nima, a maioria dos recursos � gerenciada pelo UIVRVideoEncoder
}

bool FVideoEncoderWorker::Init()
{
    UE_LOG(LogIVRVideoEncoder, Log, TEXT("Video Encoder Worker thread initialized."));
    return true;
}

uint32 FVideoEncoderWorker::Run()
{
    UE_LOG(LogIVRVideoEncoder, Log, TEXT("Video Encoder Worker thread started."));

    FIVR_VideoFrame CurrentFrame; // Vai receber o frame do tipo FIVR_VideoFrame (com TSharedPtr)
    while (!bShouldStop) 
    {
        while (FrameQueue.Dequeue(CurrentFrame)) // Dequeue de FIVR_VideoFrame
        {
            if (bShouldStop) 
            {
                // Se o thread foi sinalizado para parar, libera o frame atual antes de sair.
                if (FramePool && CurrentFrame.RawDataPtr.IsValid())
                {
                    FramePool->ReleaseFrame(CurrentFrame.RawDataPtr);
                }
                break; 
            }
            
            //Acessa os dados do buffer via RawDataPtr
            if (!CurrentFrame.RawDataPtr.IsValid() || CurrentFrame.RawDataPtr->Num() == 0)
            {
                UE_LOG(LogIVRVideoEncoder, Error, TEXT("Video Encoder Worker: Received invalid or empty frame buffer. Dropping frame."));
                // Libera o buffer para o pool, mesmo que inv�lido.
                if (FramePool && CurrentFrame.RawDataPtr.IsValid())
                {
                    FramePool->ReleaseFrame(CurrentFrame.RawDataPtr);
                }
                continue; 
            }

            UE_LOG(LogIVRVideoEncoder, Warning, TEXT("Video Encoder Worker: Attempting to write %d bytes to pipe (Frame %dx%d)."), 
                CurrentFrame.RawDataPtr->Num(), CurrentFrame.Width, CurrentFrame.Height);

            // Escreve o frame no pipe
            if (VideoInputPipe.Write(CurrentFrame.RawDataPtr->GetData(), CurrentFrame.RawDataPtr->Num()))
            {
                UE_LOG(LogIVRVideoEncoder, Warning, TEXT("Video Encoder Worker: Successfully wrote %d bytes to video pipe."),CurrentFrame.RawDataPtr->Num());
            }
            else
            {
                UE_LOG(LogIVRVideoEncoder, Error, TEXT("Failed to write video frame to pipe. Pipe may be closed or in error state. Signalling worker stop."));
                bShouldStop.AtomicSet(true); 
            }

            // SEMPRE RETORNA O FRAME PARA O POOL AP�S US�-LO
            if (FramePool && CurrentFrame.RawDataPtr.IsValid())
            {
                FramePool->ReleaseFrame(CurrentFrame.RawDataPtr);
            }
        }
        // Se a fila estiver vazia e n�o houver mais frames ou n�o for para parar, espera por um novo evento.
        if (FrameQueue.IsEmpty() && !bShouldStop)
        {
            NewFrameEvent->Wait(100); // Espera por at� 100ms por um novo frame ou sinal de parada
        }
    }

    UE_LOG(LogIVRVideoEncoder, Log, TEXT("Video Encoder Worker thread stopped."));
    return 0;
}

void FVideoEncoderWorker::Stop()
{
    bShouldStop.AtomicSet(true); 
    if (NewFrameEvent) NewFrameEvent->Trigger();
}

void FVideoEncoderWorker::Exit()
{
    UE_LOG(LogIVRVideoEncoder, Log, TEXT("Video Encoder Worker thread exiting."));
}

// =====================================================================================
// UIVRVideoEncoder Implementation
// =====================================================================================

UIVRVideoEncoder::UIVRVideoEncoder()
     : EncoderCommandFactory(nullptr)
    , FFmpegProcHandle() 
    , FFmpegStdoutLogReader(nullptr)
    , FFmpegStderrLogReader(nullptr)
    , FFmpegReadPipeStdout(nullptr)
    , FFmpegWritePipeStdout(nullptr)
    , FFmpegReadPipeStderr(nullptr)
    , FFmpegWritePipeStderr(nullptr)
    , bStopWorkerThread(false)
    , bNoMoreFramesToEncode(false)
    , bIsInitialized(false) 
    , WorkerRunnable(nullptr)
    , WorkerThread(nullptr)
    , FramePool(nullptr) // Inicializa o FramePool como nullptr
{
    NewFrameEvent = FPlatformProcess::GetSynchEventFromPool(false);
}

UIVRVideoEncoder::~UIVRVideoEncoder()
{
    // Destructor (BeginDestroy � o principal ponto de limpeza para UObjects)
}

void UIVRVideoEncoder::BeginDestroy()
{
    // Garante que o ShutdownEncoder seja chamado para limpar recursos, caso o UObject seja destru�do antes.
    ShutdownEncoder(); 
    
    if (NewFrameEvent)
    {
        FPlatformProcess::ReturnSynchEventToPool(NewFrameEvent);
        NewFrameEvent = nullptr;
    }

    Super::BeginDestroy();
}

FString UIVRVideoEncoder::GetFFmpegExecutablePathInternal() const
{
    // Se FFmpegExecutablePath estiver definido no Blueprint (EditAnywhere), use-o.
    if (!FFmpegExecutablePath.IsEmpty())
    {
        return FFmpegExecutablePath;
    }

    // Caso contr�rio, construa o caminho padr�o relativo ao plugin.
    FString PluginDir = FPaths::ProjectPluginsDir() / TEXT("IVR");
    FString Path = FPaths::Combine(PluginDir, TEXT("ThirdParty"), TEXT("FFmpeg"), TEXT("Binaries"));

#if PLATFORM_WINDOWS
    Path = FPaths::Combine(Path, TEXT("Win64"), TEXT("ffmpeg.exe"));
#elif PLATFORM_LINUX
    Path = FPaths::Combine(Path, TEXT("Linux"), TEXT("ffmpeg")); 
#elif PLATFORM_MAC
    Path = FPaths::Combine(Path, TEXT("Mac"), TEXT("ffmpeg")); 
#else
    UE_LOG(LogIVRVideoEncoder, Error, TEXT("FFmpeg executable path not defined for current platform!"));
    return FString();
#endif

    FPaths::NormalizeDirectoryName(Path);
    return Path;
}


bool UIVRVideoEncoder::Initialize(const FIVR_VideoSettings& Settings, const FString& InFFmpegExecutablePath, int32 InActualFrameWidth, int32 InActualFrameHeight, UIVRFramePool* InFramePool) 
{
    if (bIsInitialized) 
    {
        UE_LOG(LogIVRVideoEncoder, Warning, TEXT("UIVRVideoEncoder is already initialized. Call ShutdownEncoder() first."));
        return false;
    }

    CurrentSettings = Settings;
    FFmpegExecutablePath = InFFmpegExecutablePath;
    ActualProcessingWidth = InActualFrameWidth;   // Armazena a largura real
    ActualProcessingHeight = InActualFrameHeight; // Armazena a altura real
    FramePool = InFramePool; 

    if (!FramePool) // Verifica se o FramePool � v�lido
    {
        UE_LOG(LogIVRVideoEncoder, Error, TEXT("UIVRVideoEncoder::Initialize: FramePool is null. Cannot initialize."));
        return false;
    }

    // Crie o UIVRECFactory se ainda n�o existir
    if (!EncoderCommandFactory)
    {
        // Garante que a factory seja gerenciada pelo GC
        EncoderCommandFactory = NewObject<UIVRECFactory>(this, UIVRECFactory::StaticClass(), TEXT("FFmpegCommandFactory")); 
        if (!EncoderCommandFactory)
        {
            UE_LOG(LogIVRVideoEncoder, Error, TEXT("Failed to create UIVRECFactory instance."));
            return false;
        }
    }
    EncoderCommandFactory->IVR_SetVideoSettings(CurrentSettings);
    EncoderCommandFactory->IVR_SetActualVideoDimensions(ActualProcessingWidth, ActualProcessingHeight); // NOVO
    EncoderCommandFactory->IVR_SetExecutablePath(FFmpegExecutablePath);
    EncoderCommandFactory->IVR_SetPipeSettings(); // Define as configura��es padr�o para o pipe.

    // 1. Gerar um nome de pipe �nico para esta sess�o
    VideoPipeBaseName = FString::Printf(TEXT("IVIPipe%s"), *FGuid::NewGuid().ToString(EGuidFormats::Digits).Mid(0,5));

    // 2. Configurar o Named Pipe para v�deo
    FIVR_PipeSettings PipeSettings = EncoderCommandFactory->IVR_GetPipeSettings();
    PipeSettings.BasePipeName = VideoPipeBaseName; // Use o nome �nico gerado
    PipeSettings.bBlockingMode = true; // Escrita bloqueante para garantir dados sequenciais
    PipeSettings.bMessageMode = false; // Modo byte stream para dados de v�deo raw
    PipeSettings.bDuplexAccess = false; // Apenas o UE escreve, FFmpeg l�

    // Tentar criar o Named Pipe
    if (!VideoInputPipe.Create(PipeSettings, TEXT(""))) // Passamos string vazia para SessionID pois j� est� no BasePipeName
    {
        UE_LOG(LogIVRVideoEncoder, Error, TEXT("Failed to create video Named Pipe: %s"), *VideoInputPipe.GetFullPipeName());
        return false;
    }
    UE_LOG(LogIVRVideoEncoder, Log, TEXT("Video Named Pipe created: %s"), *VideoInputPipe.GetFullPipeName());

    // Inicia a worker thread para escrever frames no pipe
    WorkerRunnable = new FVideoEncoderWorker(this, FrameQueue, VideoInputPipe, bStopWorkerThread, bNoMoreFramesToEncode, NewFrameEvent, FramePool); // NOVO
    WorkerThread = FRunnableThread::Create(WorkerRunnable, TEXT("IVRVideoEncoderWorkerThread"), 0, TPri_Normal);

    if (!WorkerThread)
    {
        UE_LOG(LogIVRVideoEncoder, Error, TEXT("Failed to create video encoder worker thread. Cleaning up."));
        InternalCleanupEncoderResources(); // Cleanup the pipe
        delete WorkerRunnable; 
        WorkerRunnable = nullptr;
        return false;
    }

    bIsInitialized.AtomicSet(true); 
    UE_LOG(LogIVRVideoEncoder, Log, TEXT("UIVRVideoEncoder initialized successfully."));
    return true;
}

bool UIVRVideoEncoder::LaunchEncoder(const FString& LiveOutputFilePath)
{
    if (!bIsInitialized)
    {
        UE_LOG(LogIVRVideoEncoder, Error, TEXT("Encoder is not initialized. Call Initialize() first."));
        return false;
    }

    if (FFmpegProcHandle.IsValid())
    {
        UE_LOG(LogIVRVideoEncoder, Warning, TEXT("FFmpeg process is already running. Please call ShutdownEncoder() first."));
        return false;
    }

    // Limpa handle de processo anterior, se houver
    if (FFmpegProcHandle.IsValid())
    {
        UE_LOG(LogIVRVideoEncoder, Warning, TEXT("FFmpeg process already running. Terminating previous process."));
        FPlatformProcess::TerminateProc(FFmpegProcHandle);
        FPlatformProcess::CloseProc(FFmpegProcHandle);
        FFmpegProcHandle.Reset();
    }

    // Setta o caminho de sa�da do v�deo ao vivo
    EncoderCommandFactory->IVR_SetOutputFilePath(LiveOutputFilePath);
    // Setta o caminho do pipe de entrada para o FFmpeg
    EncoderCommandFactory->IVR_SetInPipePath(VideoInputPipe.GetFullPipeName());

    // Pega Executavel FFmpeg
    FString ExecPath = GetFFmpegExecutablePathInternal();
    if (ExecPath.IsEmpty())
    {
        UE_LOG(LogIVRVideoEncoder, Error, TEXT("FFmpeg executable path is empty. Cannot launch encoder."));
        return false;
    }

    // Constr�i o Comando FFmpeg para a grava��o ao vivo (ex: libx264)
    EncoderCommandFactory->IVR_BuildLibx264Command();
    FString Arguments = EncoderCommandFactory->IVR_GetEncoderCommand("libx264");
    
    UE_LOG(LogIVRVideoEncoder, Log, TEXT("Launching FFmpeg. Executable: %s , Arguments: %s"), *ExecPath, *Arguments);

    // Pipes de Sa�da e Erro
    FPlatformProcess::CreatePipe(FFmpegReadPipeStdout, FFmpegWritePipeStdout);
    FPlatformProcess::CreatePipe(FFmpegReadPipeStderr, FFmpegWritePipeStderr); 
    
    uint32 LaunchedProcessId = 0; 

    FFmpegProcHandle = FPlatformProcess::CreateProc(
        *ExecPath,
        *Arguments,
        false,   // bLaunchDetached
        true,    // bLaunchHidden
        true,    // bLaunchReallyHidden
        &LaunchedProcessId,
        -1,       // PriorityModifier
        nullptr, // OptionalWorkingDirectory
        FFmpegWritePipeStdout, // stdout do FFmpeg vai para este pipe
        FFmpegWritePipeStderr  // stderr do FFmpeg vai para este pipe
    );

    if (!FFmpegProcHandle.IsValid())
    {
        UE_LOG(LogIVRVideoEncoder, Error, TEXT("Failed to create FFmpeg process. Check path and arguments."));
        // Fecha ambos os pares de pipes em caso de falha no lan�amento
        FPlatformProcess::ClosePipe(FFmpegReadPipeStdout, FFmpegWritePipeStdout);
        FPlatformProcess::ClosePipe(FFmpegReadPipeStderr, FFmpegWritePipeStderr);
        FFmpegReadPipeStdout = nullptr; FFmpegWritePipeStdout = nullptr;
        FFmpegReadPipeStderr = nullptr; FFmpegWritePipeStderr = nullptr;
        return false;
    }

    UE_LOG(LogIVRVideoEncoder, Log, TEXT("FFmpeg main process launched successfully. PID: %d"), LaunchedProcessId);
    
    // Cria dois FFMpegLogReader, um para stdout e outro para stderr
    FFmpegStdoutLogReader = new FFMpegLogReader(FFmpegReadPipeStdout, TEXT("FFmpeg STDOUT"));
    FFmpegStdoutLogReader->Start();

    FFmpegStderrLogReader = new FFMpegLogReader(FFmpegReadPipeStderr, TEXT("FFmpeg STDERR"));
    FFmpegStderrLogReader->Start();

    // Importante: Feche as extremidades de escrita dos pipes no processo pai, pois o FFmpeg as herdou.
    FPlatformProcess::ClosePipe(nullptr, FFmpegWritePipeStdout);
    FPlatformProcess::ClosePipe(nullptr, FFmpegWritePipeStderr);

    // AGUARDA CONEX�O DO NAMED PIPE DE ENTRADA
    UE_LOG(LogIVRVideoEncoder, Log, TEXT("Awaiting FFmpeg connection to video input pipe..."));
    if (!VideoInputPipe.Connect())
    {
        UE_LOG(LogIVRVideoEncoder, Error, TEXT("Failed to connect Video Named Pipe to FFmpeg. Aborting encoding."));
        ShutdownEncoder(); // Realiza uma limpeza completa em caso de falha de conex�o
        return false;
    }
    UE_LOG(LogIVRVideoEncoder, Log, TEXT("Video input pipe successfully connected."));

    return true;
}

void UIVRVideoEncoder::ShutdownEncoder()
{
    if (!bIsInitialized && !FFmpegProcHandle.IsValid() && !WorkerThread) 
    {
        UE_LOG(LogIVRVideoEncoder, Warning, TEXT("UIVRVideoEncoder is not initialized or already shut down."));
        return;
    }

    UE_LOG(LogIVRVideoEncoder, Log, TEXT("Shutting down UIVRVideoEncoder..."));

    // 1. Sinaliza � worker thread para parar
    bStopWorkerThread.AtomicSet(true); 
    if (NewFrameEvent) NewFrameEvent->Trigger(); // Acorda a thread caso esteja esperando por um evento

    // 2. Aguarda a conclus�o da worker thread
    if (WorkerThread)
    {
        WorkerThread->WaitForCompletion();
        delete WorkerThread;
        WorkerThread = nullptr;
        delete WorkerRunnable;
        WorkerRunnable = nullptr;
    }

    // 3. Limpa os recursos internos (pipes de entrada) e processo FFmpeg
    InternalCleanupEncoderResources();

    bIsInitialized.AtomicSet(false); 
    UE_LOG(LogIVRVideoEncoder, Log, TEXT("UIVRVideoEncoder shut down successfully."));
}

bool UIVRVideoEncoder::EncodeFrame(FIVR_VideoFrame Frame) // Assinatura mudada
{
    if (!bIsInitialized) 
    {
        UE_LOG(LogIVRVideoEncoder, Error, TEXT("UIVRVideoEncoder is not initialized. Cannot encode frame."));
        return false;
    }
    
    if (bNoMoreFramesToEncode) 
    {
        UE_LOG(LogIVRVideoEncoder, Warning, TEXT("UIVRVideoEncoder has been signaled that no more frames are coming. Frame dropped."));
        
        // Libera o frame para o pool se n�o puder ser enfileirado
        if (FramePool && Frame.RawDataPtr.IsValid())
        {
            FramePool->ReleaseFrame(Frame.RawDataPtr);
        }

        return false;
    }

    // LOG DE DEBUG: Confirma o tamanho do frame antes de enfileirar no Encoder
    UE_LOG(LogIVRVideoEncoder, Warning, TEXT("UIVRVideoEncoder: Enqueuing frame for worker. RawDataPtr size: %d"), 
        Frame.RawDataPtr.IsValid() ? Frame.RawDataPtr->Num() : 0);

    FrameQueue.Enqueue(MoveTemp(Frame)); // Usa MoveTemp para otimizar o TSharedPtr
    
    if (NewFrameEvent) NewFrameEvent->Trigger();

    return true;
}

bool UIVRVideoEncoder::FinishEncoding()
{
     if (!bIsInitialized) 
    {
        UE_LOG(LogIVRVideoEncoder, Error, TEXT("UIVRVideoEncoder is not initialized. Cannot finish encoding."));
        return false;
    }

    UE_LOG(LogIVRVideoEncoder, Log, TEXT("Signaling UIVRVideoEncoder to finish encoding..."));

    // Sinaliza que n�o haver� mais frames para codificar
    bNoMoreFramesToEncode.AtomicSet(true);
    if (NewFrameEvent) NewFrameEvent->Trigger(); // Acorda a thread para processar quaisquer frames remanescentes na fila

    // Aguarda ativamente a fila esvaziar para garantir que todos os frames sejam escritos no pipe
    while (!FrameQueue.IsEmpty() && !bStopWorkerThread) 
    {
        FPlatformProcess::Sleep(0.01f); // Pequena pausa para permitir que o worker processe
    }

    // Fecha o pipe de entrada para sinalizar EOF ao FFmpeg.
    // � crucial fechar o pipe APENAS depois que todos os dados foram escritos.
    if (VideoInputPipe.IsValid())
    {
        VideoInputPipe.Close(); 
        UE_LOG(LogIVRVideoEncoder, Log, TEXT("Video input pipe closed, signaling EOF to FFmpeg."));
    }
    
    UE_LOG(LogIVRVideoEncoder, Log, TEXT("UIVRVideoEncoder finished sending video data."));
    return true;
}

bool UIVRVideoEncoder::ConcatenateVideos(const TArray<FString>& InTakePaths, const FString& InMasterOutputPath)
{
    if (InTakePaths.Num() == 0)
    {
        UE_LOG(LogIVRVideoEncoder, Warning, TEXT("No take paths provided for concatenation."));
        return false;
    }

    // 1. Criar um arquivo tempor�rio com a lista de takes
    FString FileListPath = FPaths::Combine(FPaths::ProjectSavedDir(), TEXT("IVRTemp"), TEXT("filelist.txt"));
    FString FileListContent;

    for (const FString& TakePath : InTakePaths)
    {
        FileListContent += FString::Printf(TEXT("file '%s'\n"), *TakePath);
    }

    if (!FFileHelper::SaveStringToFile(FileListContent, *FileListPath))
    {
        UE_LOG(LogIVRVideoEncoder, Error, TEXT("Failed to create filelist.txt for concatenation at: %s"), *FileListPath);
        return false;
    }
    UE_LOG(LogIVRVideoEncoder, Log, TEXT("Created filelist for concatenation at: %s"), *FileListPath);

    // 2. Construir o comando FFmpeg para concatena��o
    EncoderCommandFactory->IVR_BuildConcatenationCommand(FileListPath, InMasterOutputPath);
    FString ConcatenationArguments = EncoderCommandFactory->IVR_GetEncoderCommand("ConcatenateTakes");

    FString ExecPath = GetFFmpegExecutablePathInternal();
    if (ExecPath.IsEmpty())
    {
        UE_LOG(LogIVRVideoEncoder, Error, TEXT("FFmpeg executable path is empty. Cannot concatenate videos."));
        // Tentar apagar o filelist.txt
        IPlatformFile& PlatformFile = FPlatformFileManager::Get().GetPlatformFile();
        PlatformFile.DeleteFile(*FileListPath);
        return false;
    }

    UE_LOG(LogIVRVideoEncoder, Log, TEXT("Launching FFmpeg for concatenation. Executable: %s , Arguments: %s"), *ExecPath, *ConcatenationArguments);

    // 3. Lan�ar um novo processo FFmpeg para a concatena��o
    FProcHandle ConcatenationProcHandle = FPlatformProcess::CreateProc(
        *ExecPath,
        *ConcatenationArguments,
        false,   // bLaunchDetached
        true,    // bLaunchHidden
        true,    // bLaunchReallyHidden
        nullptr, // LaunchedProcessId
        -1,      // PriorityModifier
        nullptr, // OptionalWorkingDirectory
        nullptr, // StdOut (n�o precisamos capturar para concatena��o simples)
        nullptr  // StdErr
    );

    if (!ConcatenationProcHandle.IsValid())
    {
        UE_LOG(LogIVRVideoEncoder, Error, TEXT("Failed to create FFmpeg process for concatenation. Check path and arguments."));
        IPlatformFile& PlatformFile = FPlatformFileManager::Get().GetPlatformFile();
        PlatformFile.DeleteFile(*FileListPath);
        return false;
    }

    // 4. Esperar o processo de concatena��o terminar
    UE_LOG(LogIVRVideoEncoder, Log, TEXT("Waiting for FFmpeg concatenation process to complete..."));
    FPlatformProcess::WaitForProc(ConcatenationProcHandle);
    
    int32 ReturnCode = -1;
    FPlatformProcess::GetProcReturnCode(ConcatenationProcHandle, &ReturnCode);
    UE_LOG(LogIVRVideoEncoder, Log, TEXT("FFmpeg concatenation process finished with code: %d"), ReturnCode);

    // 5. Limpar recursos
    FPlatformProcess::CloseProc(ConcatenationProcHandle);
    
    // Apagar o arquivo tempor�rio
    IPlatformFile& PlatformFile = FPlatformFileManager::Get().GetPlatformFile();
    PlatformFile.DeleteFile(*FileListPath);

    if (ReturnCode != 0) // FFmpeg retorna 0 para sucesso
    {
        UE_LOG(LogIVRVideoEncoder, Error, TEXT("FFmpeg concatenation failed with return code: %d. Check FFmpeg logs for details."), ReturnCode);
        return false;
    }

    UE_LOG(LogIVRVideoEncoder, Log, TEXT("Videos concatenated successfully to: %s"), *InMasterOutputPath);
    return true;
}

void UIVRVideoEncoder::InternalCleanupEncoderResources()
{
    UE_LOG(LogIVRVideoEncoder, Log, TEXT("Cleaning up video encoder internal resources..."));

    // Apenas fecha o pipe se ele ainda estiver aberto (FinishEncoding j� o faz).
    if (VideoInputPipe.IsValid())
    {
        VideoInputPipe.Close();
        UE_LOG(LogIVRVideoEncoder, Log, TEXT("Video input pipe explicitly closed during cleanup."));
    }

    // Limpa e deleta os leitores de log do FFmpeg (stdout e stderr)
    if (FFmpegStdoutLogReader)
    {
        FFmpegStdoutLogReader->EnsureCompletion();
        delete FFmpegStdoutLogReader;
        FFmpegStdoutLogReader = nullptr;
    }

    if (FFmpegStderrLogReader)
    {
        FFmpegStderrLogReader->EnsureCompletion();
        delete FFmpegStderrLogReader;
        FFmpegStderrLogReader = nullptr;
    }
    
    // Espera o processo FFmpeg terminar completamente
    if (FFmpegProcHandle.IsValid())
    {
        UE_LOG(LogIVRVideoEncoder, Log, TEXT("Waiting for main FFmpeg process to complete..."));
        FPlatformProcess::WaitForProc(FFmpegProcHandle); 
        
        int32 ReturnCode = -1;
        FPlatformProcess::GetProcReturnCode(FFmpegProcHandle, &ReturnCode); 
        UE_LOG(LogIVRVideoEncoder, Log, TEXT("Main FFmpeg process finished with code: %d"), ReturnCode);

        // For�a o fechamento do processo FFmpeg se ele ainda estiver rodando (caso n�o tenha terminado graciosamente)
        if (FPlatformProcess::IsProcRunning(FFmpegProcHandle))
        {
            UE_LOG(LogIVRVideoEncoder, Warning, TEXT("Main FFmpeg process did not terminate gracefully. Terminating forcefully."));
            FPlatformProcess::TerminateProc(FFmpegProcHandle);
        }
        FPlatformProcess::CloseProc(FFmpegProcHandle); // Libera o handle do processo
        FFmpegProcHandle.Reset();
    }

    UE_LOG(LogIVRVideoEncoder, Log, TEXT("Video encoder internal resources cleaned up."));
}
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Recording\IVRVideoEncoder.cpp ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Recording\IVRVideoFrameSource.cpp ---
// Fill out your copyright notice in the Description page of Project Settings.
#include "Recording/IVRVideoFrameSource.h"
#include "IVR.h"
#include "Engine/World.h"
#include "Async/Async.h"
#include "HAL/PlatformProcess.h"
#include "HAL/PlatformTime.h"
#include <atomic> // Adicionado para std::atomic

#if WITH_OPENCV
#include "OpenCVHelper.h"
#include "PreOpenCVHeaders.h"

#undef check // the check macro causes problems with opencv headers
#pragma warning(disable: 4668) // 'symbol' not defined as a preprocessor macro, replacing with '0' for 'directives'
#pragma warning(disable: 4828) // The character set in the source file does not support the character used in the literal
#include <opencv2/opencv.hpp>
#include <opencv2/videoio.hpp> // Para cv::VideoCapture
#include <opencv2/imgproc.hpp> // Para cv::cvtColor

#include "PostOpenCVHeaders.h"
#endif

// ==============================================================================
// FVideoFileCaptureWorker Implementation (FRunnable para Thread de Captura de Arquivo)
// ==============================================================================

/**
 * @brief Worker thread para ler frames de um arquivo de vdeo usando OpenCV.
 * Esta classe opera em um thread separado para evitar bloqueios do Game Thread.
 */
class FVideoFileCaptureWorker : public FRunnable
{
public:
    /**
     * @brief Construtor do worker.
     * @param InFramePool Referncia ao pool de frames para adquirir buffers.
     * @param InQueue Fila para enfileirar frames capturados.
     * @param InStopFlag Flag para sinalizar a parada do thread.
     * @param InNewFrameEvent Evento para sinalizar novos frames.
     * @param InVideoFilePath Caminho para o arquivo de vdeo.
     * @param InDesiredFPS Taxa de quadros desejada para leitura (pode no ser respeitada pela webcam).
     * @param InLoopPlayback Se o vdeo deve ser reproduzido em loop.
     */
    FVideoFileCaptureWorker(UIVRFramePool* InFramePool, TQueue<FIVR_VideoFrame, EQueueMode::Mpsc>& InQueue, FThreadSafeBool& InStopFlag, FEvent* InNewFrameEvent, const FString& InVideoFilePath, float InDesiredFPS, bool InLoopPlayback)
        : CapturedFrameQueue(InQueue)
        , FramePool(InFramePool)
        , bShouldStop(InStopFlag)
        , NewFrameEvent(InNewFrameEvent)
        , VideoFilePath(InVideoFilePath)
        , DesiredFPS(InDesiredFPS)
        , bLoopPlayback(InLoopPlayback)
    {}

    /**
     * @brief Destrutor do worker, libera o VideoCapture.
     */
    virtual ~FVideoFileCaptureWorker()
    {
        if (VideoCapture.isOpened())
        {
            VideoCapture.release();
        }
    }

    /**
     * @brief Inicializa o worker, tenta abrir o arquivo de vdeo.
     * @return true se o arquivo foi aberto com sucesso, false caso contrrio.
     */
    virtual bool Init() override
    {
        // Converte FString para std::string, pois OpenCV opera com ela
        std::string VideoPathStd = TCHAR_TO_UTF8(*VideoFilePath);
        VideoCapture.open(VideoPathStd);

        if (!VideoCapture.isOpened())
        {
            UE_LOG(LogIVRFrameSource, Error, TEXT("VideoFileCaptureWorker: Failed to open video file: %s"), *VideoFilePath);
            return false;
        }

        // Tenta definir FPS de leitura se o DesiredFPS for diferente do nativo do vdeo
        // Nota: cv::CAP_PROP_FPS  o FPS *nativo* do vdeo. No podemos mudar a taxa de decodificao
        // de forma arbitrria facilmente. A cadncia de broadcast ser controlada pelo GameThread.
        // --- NOVO: Captura o FPS nativo do vdeo ---
        ActualVideoFileFPS.store((float)VideoCapture.get(cv::CAP_PROP_FPS)); // Usando store() para std::atomic
        // --- FIM NOVO ---
        VideoCapture.set(cv::CAP_PROP_FPS, DesiredFPS);

        // Atualiza as dimenses reais aps a abertura
        ActualFrameWidth.Set((int32)VideoCapture.get(cv::CAP_PROP_FRAME_WIDTH));
        ActualFrameHeight.Set((int32)VideoCapture.get(cv::CAP_PROP_FRAME_HEIGHT));

        UE_LOG(LogIVRFrameSource, Log, TEXT("VideoFileCaptureWorker: Opened video %s. Actual resolution: %dx%d, Actual FPS: %.1f"),
               *VideoFilePath, ActualFrameWidth.GetValue(), ActualFrameHeight.GetValue(), ActualVideoFileFPS.load()); // Usando load() para std::atomic

        bShouldStop.AtomicSet(false);
        return true;
    }

    /**
     * @brief Loop principal do worker thread para ler frames.
     * @return 0 ao sair.
     */
    virtual uint32 Run() override
    {
        UE_LOG(LogIVRFrameSource, Log, TEXT("VideoFileCaptureWorker: Running."));
        cv::Mat Frame; // Matriz OpenCV para armazenar o frame
        
        while (!bShouldStop)
        {
            if (!VideoCapture.isOpened())
            {
                UE_LOG(LogIVRFrameSource, Warning, TEXT("VideoFileCaptureWorker: Video capture not open, stopping thread."));
                bShouldStop.AtomicSet(true);
                break;
            }

            // L um frame do vdeo
            VideoCapture.read(Frame);

            if (Frame.empty())
            {
                // Fim do vdeo ou erro de leitura
                if (bLoopPlayback)
                {
                    UE_LOG(LogIVRFrameSource, Log, TEXT("VideoFileCaptureWorker: End of video reached, looping back."));
                    VideoCapture.set(cv::CAP_PROP_POS_FRAMES, 0); // Volta para o incio do vdeo
                    VideoCapture.read(Frame); // Tenta ler o primeiro frame
                    if (Frame.empty()) // Se ainda estiver vazio, algo est errado
                    {
                        UE_LOG(LogIVRFrameSource, Error, TEXT("VideoFileCaptureWorker: Failed to loop video or read first frame after loop. Stopping."));
                        bShouldStop.AtomicSet(true);
                        break;
                    }
                }
                else
                {
                    UE_LOG(LogIVRFrameSource, Log, TEXT("VideoFileCaptureWorker: End of video reached, stopping."));
                    bShouldStop.AtomicSet(true);
                    break;
                }
            }

            // Adquire um buffer do pool (otimiza reuso de memria)
            TSharedPtr<TArray<uint8>> FrameBuffer = FramePool->AcquireFrame();
            if (!FrameBuffer.IsValid())
            {
                UE_LOG(LogIVRFrameSource, Error, TEXT("VideoFileCaptureWorker: Failed to acquire frame buffer from pool. Dropping frame."));
                continue; // Pula este frame
            }

            // Converte o frame OpenCV (geralmente BGR) para BGRA (formato esperado pelo FFmpeg)
            cv::Mat BGRAFrame;
            cv::cvtColor(Frame, BGRAFrame, cv::COLOR_BGR2BGRA);

            // Garante que o buffer tem o tamanho correto e copia os dados do frame BGRA
            // Calcula o tamanho de uma linha de pixels sem preenchimento
            const int32 RowSizeInBytes = BGRAFrame.cols * BGRAFrame.elemSize();
            // Garante que o buffer tem o tamanho correto para a imagem compactada (sem padding)
            FrameBuffer->SetNumUninitialized(BGRAFrame.rows * RowSizeInBytes);

            // Copia a imagem linha por linha para evitar problemas de stride/padding
            for (int32 i = 0; i < BGRAFrame.rows; ++i)
            {
                // Origem: Aponta para o incio da linha 'i' na Mat do OpenCV, usando seu stride (passo)
                const uint8* SourceRowPtr = BGRAFrame.data + (i * BGRAFrame.step[0]);
                // Destino: Aponta para o incio da linha 'i' no nosso buffer, que  compactado
                uint8* DestRowPtr = FrameBuffer->GetData() + (i * RowSizeInBytes);
                // Copia apenas os dados da linha (sem padding)
                FMemory::Memcpy(DestRowPtr, SourceRowPtr, RowSizeInBytes);
            }
            
            // Cria o FIVR_VideoFrame (contm o TSharedPtr para o buffer)
            FIVR_VideoFrame NewFrame(BGRAFrame.cols, BGRAFrame.rows, FPlatformTime::Seconds());
            NewFrame.RawDataPtr = FrameBuffer; // Atribui o buffer adquirido
            
            // Enfileira o frame para ser consumido pelo Game Thread
            CapturedFrameQueue.Enqueue(MoveTemp(NewFrame));
            
            // Sinaliza o evento para o Game Thread, indicando que h um novo frame disponvel
            NewFrameEvent->Trigger(); 
        }

        UE_LOG(LogIVRFrameSource, Log, TEXT("VideoFileCaptureWorker: Exiting run loop."));
        return 0;
    }

    /**
     * @brief Sinaliza ao worker thread para parar.
     */
    virtual void Stop() override
    {
        bShouldStop.AtomicSet(true);
        if (NewFrameEvent) NewFrameEvent->Trigger();
        UE_LOG(LogIVRFrameSource, Log, TEXT("VideoFileCaptureWorker: Stop signal received."));
    }

    /**
     * @brief Limpeza final ao sair do thread.
     */
    virtual void Exit() override
    {
        if (VideoCapture.isOpened())
        {
            VideoCapture.release();
        }
        UE_LOG(LogIVRFrameSource, Log, TEXT("VideoFileCaptureWorker: Exited."));
    }

public: 
    // === Membros da classe que precisam ser declarados aqui para a defini��o local ===
    cv::VideoCapture VideoCapture; 
    FThreadSafeCounter ActualFrameWidth;
    FThreadSafeCounter ActualFrameHeight;
    std::atomic<float> ActualVideoFileFPS; // NOVO: Usando std::atomic para float thread-safe

private:
    
    TQueue<FIVR_VideoFrame, EQueueMode::Mpsc>& CapturedFrameQueue;
    UIVRFramePool* FramePool;
    FThreadSafeBool& bShouldStop;
    FEvent* NewFrameEvent;

    FString VideoFilePath;
    float DesiredFPS;
    bool bLoopPlayback;
};


// ==============================================================================
// UIVRVideoFrameSource Implementation
// ==============================================================================

UIVRVideoFrameSource::UIVRVideoFrameSource()
    : UIVRFrameSource()
    , WorkerRunnable(nullptr)
    , WorkerThread(nullptr)
{
    NewFrameEvent = FPlatformProcess::GetSynchEventFromPool(false); // false para auto-reset
}

void UIVRVideoFrameSource::BeginDestroy()
{
    Shutdown(); 

    if (NewFrameEvent)
    {
        FPlatformProcess::ReturnSynchEventToPool(NewFrameEvent);
        NewFrameEvent = nullptr;
    }

    Super::BeginDestroy();
}

void UIVRVideoFrameSource::Initialize(UWorld* World, const FIVR_VideoSettings& Settings, UIVRFramePool* InFramePool)
{
    if (!World || !InFramePool)
    {
        UE_LOG(LogIVRFrameSource, Error, TEXT("UIVRVideoFrameSource::Initialize: World or FramePool is null."));
        return;
    }
    CurrentWorld = World;
    FrameSourceSettings = Settings;
    FramePool = InFramePool;

    // Cria a instncia do worker runnable
    WorkerRunnable = new FVideoFileCaptureWorker(
        FramePool,
        CapturedFrameQueue,
        bShouldStopWorker,
        NewFrameEvent,
        Settings.IVR_VideoFilePath,
        Settings.FPS, // Usamos Settings.FPS como o FPS desejado para o OpenCV
        Settings.IVR_LoopVideoPlayback
    );

    if (WorkerRunnable)
    {
        WorkerThread = FRunnableThread::Create(WorkerRunnable, TEXT("IVRVideoFileCaptureThread"), 0, TPri_Normal);
        if (!WorkerThread)
        {
            UE_LOG(LogIVRFrameSource, Error, TEXT("UIVRVideoFrameSource: Failed to create worker thread."));
            delete WorkerRunnable;
            WorkerRunnable = nullptr;
        }
    }
    
    // O Init() do WorkerRunnable  chamado pela prpria thread. Verificamos se a webcam abriu.
    // Damos um pequeno tempo para o Init() ser executado na thread.
    // Alternativamente, WorkerRunnable->Init() pode ser chamado explicitamente antes de FRunnableThread::Create
    // se quisermos falhar a inicializao imediatamente no GameThread.
    // Para um tratamento robusto, o Init() do worker deve retornar um bool e ser verificado aqui.
    // No entanto, FRunnableThread::Create lana a thread e seu Init(). Erros devem ser capturados no Run().
    
    // Para simplificar a verificao de sucesso na inicializao da webcam/vdeo:
    // Uma soluo mais elegante seria ter um FThreadSafeBool IsInitialized no worker
    // que seria setado para true se o OpenCV VideoCapture.open() for bem-sucedido.
    // Por enquanto, confiamos que os logs no worker indicam o estado.

    UE_LOG(LogIVRFrameSource, Log, TEXT("UIVRVideoFrameSource initialized for video file: %s."), *Settings.IVR_VideoFilePath);
}

void UIVRVideoFrameSource::Shutdown()
{
    StopCapture();

    FIVR_VideoFrame DummyFrame;
    while (CapturedFrameQueue.Dequeue(DummyFrame))
    {
        if (FramePool && DummyFrame.RawDataPtr.IsValid())
        {
            FramePool->ReleaseFrame(DummyFrame.RawDataPtr);
        }
    }

    if (WorkerThread)
    {
        WorkerThread->WaitForCompletion();
        delete WorkerThread;
        WorkerThread = nullptr;
    }
    if (WorkerRunnable)
    {
        delete WorkerRunnable;
        WorkerRunnable = nullptr;
    }

    CurrentWorld = nullptr;
    FramePool = nullptr;
    UE_LOG(LogIVRFrameSource, Log, TEXT("UIVRVideoFrameSource Shutdown."));
}

void UIVRVideoFrameSource::StartCapture()
{
    if (!CurrentWorld || !WorkerRunnable || !WorkerThread)
    {
        UE_LOG(LogIVRFrameSource, Error, TEXT("UIVRVideoFrameSource::StartCapture: Not initialized or worker not ready."));
        return;
    }
    
    bShouldStopWorker.AtomicSet(false);

    // Ajusta o FPS de polling baseado no FPS do vdeo e na velocidade de reproduo.
    // O DesiredFPS na worker  o FPS de leitura, o FPS do GameThread  a cadncia de broadcast.
    float VideoNativeFPS = GetActualVideoFileFPS(); // Obtm o FPS nativo do vdeo
    if (VideoNativeFPS <= 0.0f) VideoNativeFPS = 30.0f; // Fallback para evitar diviso por zero

    // Calcula o FPS efetivo de broadcast, considerando o VideoPlaybackSpeed
    float EffectiveFPS = VideoNativeFPS * FrameSourceSettings.IVR_VideoPlaybackSpeed;
    float PollDelay = (EffectiveFPS > 0.0f) ? (1.0f / EffectiveFPS) : (1.0f / 30.0f);

    CurrentWorld->GetTimerManager().SetTimer(FramePollTimerHandle, this, &UIVRVideoFrameSource::PollForNewFrames, PollDelay, true);
    UE_LOG(LogIVRFrameSource, Log, TEXT("UIVRVideoFrameSource: Starting frame capture from video file at %.2f FPS (effective)."), EffectiveFPS);
}

void UIVRVideoFrameSource::StopCapture()
{
    if (CurrentWorld && CurrentWorld->GetTimerManager().IsTimerActive(FramePollTimerHandle))
    {
        CurrentWorld->GetTimerManager().ClearTimer(FramePollTimerHandle);
    }
    FramePollTimerHandle.Invalidate();

    bShouldStopWorker.AtomicSet(true);
    if (NewFrameEvent) NewFrameEvent->Trigger();

    UE_LOG(LogIVRFrameSource, Log, TEXT("UIVRVideoFrameSource: Stopped frame capture."));
}

void UIVRVideoFrameSource::PollForNewFrames()
{
    FIVR_VideoFrame QueuedFrame;
    while (CapturedFrameQueue.Dequeue(QueuedFrame))
    {
        OnFrameAcquired.Broadcast(MoveTemp(QueuedFrame));
    }
}

int32 UIVRVideoFrameSource::GetActualFrameWidth() const
{
    if (WorkerRunnable)
    {
        return WorkerRunnable->ActualFrameWidth.GetValue();
    }
    return 0; 
}

int32 UIVRVideoFrameSource::GetActualFrameHeight() const
{
    if (WorkerRunnable)
    {
        return WorkerRunnable->ActualFrameHeight.GetValue();
    }
    return 0; 
}

float UIVRVideoFrameSource::GetActualVideoFileFPS() const
{
    if (WorkerRunnable)
    {
        return WorkerRunnable->ActualVideoFileFPS.load(); // Usando load() para std::atomic
    }
    return 0.0f; 
}

float UIVRVideoFrameSource::GetEffectivePlaybackFPS() const
{
    if (WorkerRunnable)
    {
        float nativeFPS = GetActualVideoFileFPS();
        if (nativeFPS > 0.0f)
        {
            return nativeFPS * FrameSourceSettings.IVR_VideoPlaybackSpeed;
        }
    }
    return 0.0f; 
}
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Recording\IVRVideoFrameSource.cpp ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Recording\IVRWebcamFrameSource.cpp ---

#include "Recording/IVRWebcamFrameSource.h"
#include "IVR.h"
#include "Engine/World.h" // Para GetWorldTimerManager
#include "Async/Async.h"
#include "HAL/PlatformProcess.h"
#include "HAL/PlatformTime.h"


#if WITH_OPENCV
#include "OpenCVHelper.h"
#include "PreOpenCVHeaders.h"

#undef check // the check macro causes problems with opencv headers
#pragma warning(disable: 4668) // 'symbol' not defined as a preprocessor macro, replacing with '0' for 'directives'
#pragma warning(disable: 4828) // The character set in the source file does not support the character used in the literal
#include <opencv2/opencv.hpp>
#include <opencv2/videoio.hpp> // Para cv::VideoCapture
#include <opencv2/imgproc.hpp> // Para cv::cvtColor

#include "PostOpenCVHeaders.h"
#endif

// ==============================================================================
// FWebcamCaptureWorker Implementation (FRunnable para Thread de Captura)
// ==============================================================================

/**
 * @brief Worker thread para capturar frames de uma webcam usando OpenCV.
 * Esta classe opera em um thread separado para evitar bloqueios do Game Thread.
 */
class FWebcamCaptureWorker : public FRunnable
{
public:
    /**
     * @brief Construtor do worker.
     * @param InFramePool Refer�ncia ao pool de frames para adquirir buffers.
     * @param InQueue Fila para enfileirar frames capturados.
     * @param InStopFlag Flag para sinalizar a parada do thread.
     * @param InNewFrameEvent Evento para sinalizar novos frames.
     * @param InDeviceIndex �ndice da webcam a ser utilizada.
     * @param InWidth Largura desejada para a captura.
     * @param InHeight Altura desejada para a captura.
     * @param InFPS FPS desejado para a captura.
     * @param InApiPreference Prefer�ncia de API para OpenCV (e.g., cv::CAP_DSHOW).
     */
    FWebcamCaptureWorker(UIVRFramePool* InFramePool, TQueue<FIVR_VideoFrame, EQueueMode::Mpsc>& InQueue, FThreadSafeBool& InStopFlag, FEvent* InNewFrameEvent, int32 InDeviceIndex, int32 InWidth, int32 InHeight, float InFPS, cv::VideoCaptureAPIs InApiPreference)
        : CapturedFrameQueue(InQueue)
        , FramePool(InFramePool)
        , bShouldStop(InStopFlag)
        , NewFrameEvent(InNewFrameEvent)
        , DeviceIndex(InDeviceIndex)
        , DesiredWidth(InWidth)
        , DesiredHeight(InHeight)
        , DesiredFPS(InFPS)
        , ApiPreference(InApiPreference)
    {}

    /**
     * @brief Destrutor do worker, libera o VideoCapture.
     */
    virtual ~FWebcamCaptureWorker()
    {
        if (WebcamCapture.isOpened())
        {
            WebcamCapture.release();
        }
    }

    /**
     * @brief Inicializa o worker. N�o abre a webcam aqui para evitar bloqueios no in�cio da thread.
     * @return true.
     */
    virtual bool Init() override
    {
        bShouldStop.AtomicSet(false);
        UE_LOG(LogIVRFrameSource, Log, TEXT("WebcamCaptureWorker: Initialized successfully. Webcam opening deferred to Run()."));
        return true;
    }

    /**
     * @brief Loop principal do worker thread para capturar frames.
     * Abertura da webcam ocorre aqui para garantir que bloqueios aconte�am no worker thread.
     * @return 0 ao sair, ou 1 se a webcam n�o puder ser aberta.
     */
    virtual uint32 Run() override
    {
        UE_LOG(LogIVRFrameSource, Log, TEXT("WebcamCaptureWorker: Running."));
        cv::Mat Frame; // Matriz OpenCV para armazenar o frame

        // Tenta abrir a webcam no in�cio do Run(), no worker thread.
        WebcamCapture.open(DeviceIndex, ApiPreference);
        if (!WebcamCapture.isOpened())
        {
            UE_LOG(LogIVRFrameSource, Error, TEXT("WebcamCaptureWorker: Failed to open webcam device %d with API %d. Stopping capture thread."), DeviceIndex, (int32)ApiPreference);
            bShouldStop.AtomicSet(true); // Sinaliza para parar
            return 1; // Retorna c�digo de erro
        }

        // Tenta definir a resolu��o, FPS e codec *ap�s* a abertura bem-sucedida
        WebcamCapture.set(cv::CAP_PROP_FRAME_WIDTH , DesiredWidth);
        WebcamCapture.set(cv::CAP_PROP_FRAME_HEIGHT, DesiredHeight);
        WebcamCapture.set(cv::CAP_PROP_FPS, DesiredFPS);
        WebcamCapture.set(cv::CAP_PROP_FOURCC, cv::VideoWriter::fourcc('M', 'J', 'P', 'G')); // Tenta MJPG para melhor FPS/qualidade

        // Verifica as configura��es aplicadas (podem n�o ser exatamente as desejadas pela webcam)
        ActualFrameWidth.Set((int32)WebcamCapture.get(cv::CAP_PROP_FRAME_WIDTH));
        ActualFrameHeight.Set((int32)WebcamCapture.get(cv::CAP_PROP_FRAME_HEIGHT));

        // Verifica as configura��es aplicadas (podem n�o ser exatamente as desejadas pela webcam)
       UE_LOG(LogIVRFrameSource, Log, TEXT("WebcamCaptureWorker: Opened device %d with API %d. Actual resolution: %dx%d, Actual FPS: %.1f"),
               DeviceIndex, (int32)ApiPreference, ActualFrameWidth.GetValue(), ActualFrameHeight.GetValue(), (float)WebcamCapture.get(cv::CAP_PROP_FPS));
        
        while (!bShouldStop)
        {
            if (!WebcamCapture.isOpened())
            {
                UE_LOG(LogIVRFrameSource, Warning, TEXT("WebcamCaptureWorker: Webcam was closed unexpectedly. Stopping capture thread."));
                bShouldStop.AtomicSet(true);
                break;
            }

            // L� um frame da webcam (geralmente � uma chamada bloqueante at� um frame estar dispon�vel)
            WebcamCapture.read(Frame);

            if (Frame.empty())
            {
                // Se o frame estiver vazio, pode ser que a webcam esteja sendo desconectada ou em um estado ruim
                UE_LOG(LogIVRFrameSource, Warning, TEXT("WebcamCaptureWorker: Empty frame received. Retrying..."));
                FPlatformProcess::Sleep(0.1f); // Pequena pausa antes de tentar novamente
                continue; // Tenta novamente na pr�xima itera��o
            }

            // Adquire um buffer do pool (otimiza reuso de mem�ria)
            TSharedPtr<TArray<uint8>> FrameBuffer = FramePool->AcquireFrame();
            if (!FrameBuffer.IsValid())
            {
                UE_LOG(LogIVRFrameSource, Error, TEXT("WebcamCaptureWorker: Failed to acquire frame buffer from pool. Dropping frame."));
                continue; // Pula este frame
            }

            // Converte o frame OpenCV (geralmente BGR) para BGRA (formato esperado pelo FFmpeg)
            cv::Mat BGRAFrame;
            cv::cvtColor(Frame, BGRAFrame, cv::COLOR_BGR2BGRA);

            // Calcula o tamanho de uma linha de pixels sem preenchimento
            const int32 RowSizeInBytes = BGRAFrame.cols * BGRAFrame.elemSize();
            // Garante que o buffer tem o tamanho correto para a imagem compactada (sem padding)
            FrameBuffer->SetNumUninitialized(BGRAFrame.rows * RowSizeInBytes);

            // *** NOVO: Copia a imagem linha por linha para evitar problemas de stride/padding ***
            for (int32 i = 0; i < BGRAFrame.rows; ++i)
            {
                // Origem: Aponta para o in�cio da linha 'i' na Mat do OpenCV, usando seu stride (passo)
                const uint8* SourceRowPtr = BGRAFrame.data + (i * BGRAFrame.step[0]);
                // Destino: Aponta para o in�cio da linha 'i' no nosso buffer, que � compactado
                uint8* DestRowPtr = FrameBuffer->GetData() + (i * RowSizeInBytes);
                // Copia apenas os dados da linha (sem padding)
                FMemory::Memcpy(DestRowPtr, SourceRowPtr, RowSizeInBytes);
            }
            // *** FIM DA NOVIDADE ***

            // Cria o FIVR_VideoFrame (cont�m o TSharedPtr para o buffer)
            FIVR_VideoFrame NewFrame(BGRAFrame.cols, BGRAFrame.rows, FPlatformTime::Seconds());
            NewFrame.RawDataPtr = FrameBuffer; // Atribui o buffer adquirido
            
            // Enfileira o frame para ser consumido pelo Game Thread
            CapturedFrameQueue.Enqueue(MoveTemp(NewFrame));
            
            // Sinaliza o evento para o Game Thread, indicando que h� um novo frame dispon�vel
            NewFrameEvent->Trigger(); 
        }

        UE_LOG(LogIVRFrameSource, Log, TEXT("WebcamCaptureWorker: Exiting run loop."));
        return 0; // Retorna sucesso
    }

    /**
     * @brief Sinaliza ao worker thread para parar.
     */
    virtual void Stop() override
    {
        bShouldStop.AtomicSet(true);
        if (NewFrameEvent) NewFrameEvent->Trigger(); // Acorda o Run para que ele possa sair do Wait
        UE_LOG(LogIVRFrameSource, Log, TEXT("WebcamCaptureWorker: Stop signal received."));
    }

    /**
     * @brief Limpeza final ao sair do thread.
     */
    virtual void Exit() override
    {
        if (WebcamCapture.isOpened())
        {
            WebcamCapture.release();
        }
        UE_LOG(LogIVRFrameSource, Log, TEXT("WebcamCaptureWorker: Exited."));
    }

public: 

    // Membros para armazenar a resolu��o real da captura, atualizados no Run()
    FThreadSafeCounter ActualFrameWidth;
    FThreadSafeCounter ActualFrameHeight;

private:

    cv::VideoCapture WebcamCapture; // Objeto de captura de v�deo do OpenCV
    TQueue<FIVR_VideoFrame, EQueueMode::Mpsc>& CapturedFrameQueue; // Refer�ncia � fila de frames
    UIVRFramePool* FramePool; // Refer�ncia ao pool para adquirir buffers
    FThreadSafeBool& bShouldStop; // Refer�ncia para a flag de parada do thread
    FEvent* NewFrameEvent; // Refer�ncia ao evento de sinaliza��o

    int32 DeviceIndex; // �ndice da webcam a ser utilizada
    int32 DesiredWidth; // Largura desejada para a captura
    int32 DesiredHeight; // Altura desejada para a captura
    float DesiredFPS; // FPS desejado para a captura
    cv::VideoCaptureAPIs ApiPreference; // Prefer�ncia de API para OpenCV
};


// ==============================================================================
// UIVRWebcamFrameSource Implementation
// ==============================================================================

UIVRWebcamFrameSource::UIVRWebcamFrameSource()
    : UIVRFrameSource()
    , WorkerRunnable(nullptr)
    , WorkerThread(nullptr)
{
    // Cria um evento de sincroniza��o que reseta automaticamente ap�s ser triggered
    NewFrameEvent = FPlatformProcess::GetSynchEventFromPool(false); 
}

void UIVRWebcamFrameSource::BeginDestroy()
{
    // Garante que a thread seja desligada e os recursos liberados durante a destrui��o do UObject
    Shutdown(); 

    // Libera o evento de sincroniza��o de volta para o pool
    if (NewFrameEvent)
    {
        FPlatformProcess::ReturnSynchEventToPool(NewFrameEvent);
        NewFrameEvent = nullptr;
    }

    Super::BeginDestroy();
}

void UIVRWebcamFrameSource::Initialize(UWorld* World, const FIVR_VideoSettings& Settings, UIVRFramePool* InFramePool)
{
    if (!World || !InFramePool)
    {
        UE_LOG(LogIVRFrameSource, Error, TEXT("UIVRWebcamFrameSource::Initialize: World or FramePool is null."));
        return;
    }
    CurrentWorld = World;
    FrameSourceSettings = Settings;
    FramePool = InFramePool;

    // Cria a inst�ncia do worker runnable
    WorkerRunnable = new FWebcamCaptureWorker(
        FramePool,
        CapturedFrameQueue,
        bShouldStopWorker,
        NewFrameEvent,
        Settings.IVR_WebcamIndex,
        (int32)Settings.IVR_WebcamResolution.X,
        (int32)Settings.IVR_WebcamResolution.Y,
        Settings.IVR_WebcamFPS,
        cv::CAP_DSHOW // Passa a prefer�ncia de API para o worker
    );

    if (WorkerRunnable)
    {
        // Cria e inicia o thread.
        WorkerThread = FRunnableThread::Create(WorkerRunnable, TEXT("IVRWebcamCaptureThread"), 0, TPri_Normal);
        if (!WorkerThread)
        {
            UE_LOG(LogIVRFrameSource, Error, TEXT("UIVRWebcamFrameSource: Failed to create worker thread."));
            delete WorkerRunnable; // Limpa o runnable se o thread n�o puder ser criado
            WorkerRunnable = nullptr;
        }
    }
    
    UE_LOG(LogIVRFrameSource, Log, TEXT("UIVRWebcamFrameSource initialized for webcam index: %d."), Settings.IVR_WebcamIndex);
}

void UIVRWebcamFrameSource::Shutdown()
{
    // Garante que a captura e o polling sejam interrompidos
    StopCapture();

    // Sinaliza � thread worker para parar e espera que ela termine
    bShouldStopWorker.AtomicSet(true);
    if (NewFrameEvent) NewFrameEvent->Trigger(); // Acorda a thread caso esteja esperando

    // Espera a thread worker terminar completamente
    if (WorkerThread)
    {
        WorkerThread->WaitForCompletion();
        delete WorkerThread;
        WorkerThread = nullptr;
    }
    // Libera a mem�ria do worker runnable
    if (WorkerRunnable)
    {
        delete WorkerRunnable;
        WorkerRunnable = nullptr;
    }

    // Limpa a fila de quaisquer frames remanescentes
    FIVR_VideoFrame DummyFrame;
    while (CapturedFrameQueue.Dequeue(DummyFrame))
    {
        // Libera o buffer do frame de volta para o pool, se for v�lido
        if (FramePool && DummyFrame.RawDataPtr.IsValid())
        {
            FramePool->ReleaseFrame(DummyFrame.RawDataPtr);
        }
    }

    // Limpa refer�ncias do UObject
    CurrentWorld = nullptr;
    FramePool = nullptr;
    UE_LOG(LogIVRFrameSource, Log, TEXT("UIVRWebcamFrameSource Shutdown."));
}

void UIVRWebcamFrameSource::StartCapture()
{
    if (!CurrentWorld || !WorkerRunnable || !WorkerThread)
    {
        UE_LOG(LogIVRFrameSource, Error, TEXT("UIVRWebcamFrameSource::StartCapture: Not initialized or worker not ready."));
        return;
    }
    
    // Reseta a flag para permitir que a thread worker execute
    bShouldStopWorker.AtomicSet(false);

    // Determina a cad�ncia de polling no Game Thread.
    // A leitura real dos frames no worker thread � t�o r�pida quanto o OpenCV permite.
    // O polling aqui controla com que frequ�ncia o Game Thread "pega" os frames da fila.
    float PollDelay = (FrameSourceSettings.IVR_WebcamFPS > 0.0f) ? (1.0f / FrameSourceSettings.IVR_WebcamFPS) : (1.0f / 30.0f);

    // Inicia o timer para polling de frames da fila
    CurrentWorld->GetTimerManager().SetTimer(FramePollTimerHandle, this, &UIVRWebcamFrameSource::PollForNewFrames, PollDelay, true);
    UE_LOG(LogIVRFrameSource, Log, TEXT("UIVRWebcamFrameSource: Starting frame capture from webcam. Polling every %.4f seconds."), PollDelay);
}

void UIVRWebcamFrameSource::StopCapture()
{
    // Para o timer de polling no Game Thread
    if (CurrentWorld && CurrentWorld->GetTimerManager().IsTimerActive(FramePollTimerHandle))
    {
        CurrentWorld->GetTimerManager().ClearTimer(FramePollTimerHandle);
    }
    FramePollTimerHandle.Invalidate();

    // Sinaliza � thread worker para parar
    bShouldStopWorker.AtomicSet(true);
    if (NewFrameEvent) NewFrameEvent->Trigger(); // Acorda a thread caso esteja esperando (para que ela possa sair do loop Run())

    UE_LOG(LogIVRFrameSource, Log, TEXT("UIVRWebcamFrameSource: Stopped frame capture."));
}

void UIVRWebcamFrameSource::PollForNewFrames()
{
    FIVR_VideoFrame QueuedFrame;
    // Enquanto houver frames na fila, os retira e broadcasta
    while (CapturedFrameQueue.Dequeue(QueuedFrame))
    {
        // Broadcast do frame processado (o TSharedPtr dentro de QueuedFrame � movido)
        OnFrameAcquired.Broadcast(MoveTemp(QueuedFrame));
    }
}

TArray<FString> UIVRWebcamFrameSource::ListWebcamDevices()
{
    TArray<FString> Devices;
    // Tenta abrir e fechar dispositivos para verificar se existem e obter algumas caracter�sticas.
    // O OpenCV n�o oferece um m�todo direto para listar nomes de dispositivos de forma multiplataforma.
    // Esta abordagem tenta os primeiros 10 �ndices de dispositivos.
    
    // NOTA: cv::VideoCapture cap(index) pode levar alguns milissegundos para abrir e fechar,
    // ent�o esta fun��o pode ser um pouco lenta dependendo do n�mero de dispositivos testados.
    
    for (int32 i = 0; i < 10; ++i) // Tenta os primeiros 10 dispositivos
    {
        // Utiliza cv::CAP_DSHOW para tentar uma abertura mais robusta durante a listagem
        cv::VideoCapture TestCapture(i, cv::CAP_DSHOW); 
        if (TestCapture.isOpened())
        {
            FString DeviceInfo = FString::Printf(TEXT("Device %d (Res: %dx%d @ %.1fFPS)"), i,
                                                (int32)TestCapture.get(cv::CAP_PROP_FRAME_WIDTH),
                                                (int32)TestCapture.get(cv::CAP_PROP_FRAME_HEIGHT),
                                                (float)TestCapture.get(cv::CAP_PROP_FPS));
            Devices.Add(DeviceInfo);
            TestCapture.release(); // Libera o recurso da webcam
        }
    }
    if (Devices.Num() == 0)
    {
        Devices.Add(TEXT("No webcams found."));
    }
    UE_LOG(LogIVRFrameSource, Log, TEXT("Listed Webcam Devices: %s"), *FString::Join(Devices, TEXT(", ")));
    return Devices;
}

int32 UIVRWebcamFrameSource::GetActualFrameWidth() const
{
    if (WorkerRunnable)
    {
        return WorkerRunnable->ActualFrameWidth.GetValue();
    }
    return 0; // Ou um valor de erro adequado
}

int32 UIVRWebcamFrameSource::GetActualFrameHeight() const
{
    if (WorkerRunnable)
    {
        return WorkerRunnable->ActualFrameHeight.GetValue();
    }
    return 0; // Ou um valor de erro adequado
}

--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\Recording\IVRWebcamFrameSource.cpp ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\UI\IVRDisplayWidget.cpp ---
// D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\UI\IVRDisplayWidget.cpp

#include "UI/IVRDisplayWidget.h"

void UIVRDisplayWidget::NativeConstruct()
{
    Super::NativeConstruct();

    // Verifica se o DisplayImage foi vinculado corretamente pelo meta = (BindWidget)
    if (!DisplayImage)
    {
        UE_LOG(LogTemp, Warning, TEXT("UIVRDisplayWidget: DisplayImage UImage component is null. "
                                      "Ensure a UImage widget named 'DisplayImage' exists in your UMG Blueprint "
                                      "that inherits from this C++ class, and that 'Is Variable' is checked."));
    }
}

void UIVRDisplayWidget::SetDisplayTexture(UTexture2D* NewTexture)
{
    if (DisplayImage)
    {
        // Define a textura usando um Brush.
        // O UMG gerenciar� o redimensionamento do Image para o tamanho da textura.
        DisplayImage->SetBrushFromTexture(NewTexture);
    }
    else
    {
        UE_LOG(LogTemp, Warning, TEXT("UIVRDisplayWidget: Cannot set texture, DisplayImage is null."));
    }
}
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Private\UI\IVRDisplayWidget.cpp ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\FFmpegLogReader.h ---
// Fill out your copyright notice in the Description page of Project Settings.
// FFmpegLogReader.h
#pragma once

#include "CoreMinimal.h"
#include "HAL/Runnable.h"
#include "HAL/RunnableThread.h"
#include "HAL/PlatformProcess.h"

// Inclua seu LogCategory
#include "IVR.h" 

/**
 * Classe para ler continuamente a sa�da de um processo externo (FFmpeg)
 * e logar no console da Unreal Engine.
 */
class FFMpegLogReader : public FRunnable
{
public:
    // NOVO: Adicionado um par�metro de prefixo para o log
    FFMpegLogReader(void* InReadPipe, const FString& InLogPrefix = TEXT("FFmpeg Output"));
    virtual ~FFMpegLogReader();

    // FRunnable interface
    virtual bool Init() override;
    virtual uint32 Run() override;
    virtual void Stop() override;
    virtual void Exit() override;

    // Fun��o para iniciar e parar a thread
    void Start();
    void EnsureCompletion();

private:
    void* ReadPipe; // O handle de leitura do pipe para o stdout/stderr do FFmpeg
    FRunnableThread* Thread;
    FThreadSafeBool bShouldStop; // Flag para parar a thread com seguran�a
    FString LogPrefix; // NOVO: Prefixo para diferenciar as mensagens de log
};

--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\FFmpegLogReader.h ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\IVR.h ---
#pragma once

#include "CoreMinimal.h"
#include "Modules/ModuleManager.h"

DECLARE_LOG_CATEGORY_EXTERN(LogIVR, Log, All);

class FIVRModule : public IModuleInterface
{
public:
    virtual void StartupModule() override;
    virtual void ShutdownModule() override;
};
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\IVR.h ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\IVRGlobalStatics.h ---
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "HAL/PlatformMisc.h" 
#include "IVRGlobalStatics.generated.h"

// Defini��o da USTRUCT para empacotar os detalhes do erro
USTRUCT(BlueprintType)
struct IVR_API FIVR_SystemErrorDetails
{
    GENERATED_BODY()

    // O c�digo num�rico do erro (usando int32 para compatibilidade com Blueprint)
    UPROPERTY(BlueprintReadOnly, Category = "Error Details")
    int32 ErrorCode = 0; 

    // A descri��o textual do erro
    UPROPERTY(BlueprintReadOnly, Category = "Error Details")
    FString ErrorDescription;
};

/**
 * 
 */
UCLASS()
class IVR_API UIVRGlobalStatics : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()

public:

	/**
	* Retorna a descri��o do �ltimo erro do sistema operacional.
    * Esta fun��o � multiplataforma, utilizando as abstra��es da Unreal Engine.
    * @param ErrorCode Opcional. O c�digo de erro a ser traduzido. Se 0, usa o �ltimo erro da thread.
    * @return Uma FString contendo a descri��o do erro.
    */
    UFUNCTION(BlueprintCallable, Category = "IVR System|Error Handling",
              meta = (DisplayName = "Get Last System Error Details",
              ToolTip = "Retrieves the last system error code and its description, multi-platform aware.",
              Keywords = "error, system, last, code, description, platform, ivr"))
    static FIVR_SystemErrorDetails GetLastSystemErrorDetails();
};

--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\IVRGlobalStatics.h ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\IVR_PipeWrapper.h ---
// Fill out your copyright notice in the Description page of Project Settings.
// IVRPipeWrapper.h
#pragma once

#include "CoreMinimal.h"
#include "IVR.h"
#include "Core/IVRTypes.h" // Inclui a USTRUCT FIVR_PipeSettings

#if PLATFORM_WINDOWS
#include "Windows/AllowWindowsPlatformTypes.h"
#include <windows.h>
#include <stdio.h> // Para GetLastError
#include "Windows/HideWindowsPlatformTypes.h"
#elif PLATFORM_LINUX || PLATFORM_MAC
#include <sys/stat.h>   // Para mkfifo
#include <fcntl.h>      // Para open, O_RDWR, O_CREAT
#include <unistd.h>     // Para close, write
#endif

// Forward declarations para tipos OS-espec�ficos
#if PLATFORM_WINDOWS
typedef void* IVR_NativePipeHandle; // HANDLE � void*
#else
typedef int IVR_NativePipeHandle; // file descriptor � int
#endif

// Define um valor inv�lido para o handle nativo
#define IVR_INVALID_NATIVE_PIPE_HANDLE ((IVR_NativePipeHandle)-1)

// Defini��o de LogCategory para FIVR_PipeWrapper
DECLARE_LOG_CATEGORY_EXTERN(LogIVRPipeWrapper, Log, All);

/**
 * Encapsula um Named Pipe multiplataforma (HANDLE no Windows, file descriptor no Linux).
 */
struct IVR_API FIVR_PipeWrapper
{
public:

     FIVR_PipeWrapper();
    ~FIVR_PipeWrapper();

     /**
    * Cria e abre o Named Pipe (Windows) ou FIFO (POSIX).
    * @param Settings As configura��es para criar o pipe.
    * @param SessionID Um ID �nico para esta sess�o, para garantir nomes de pipe �nicos.
    * @param InWidth Largura do v�deo (usada para calcular o tamanho do buffer do pipe).
    * @param InHeight Altura do v�deo (usada para calcular o tamanho do buffer do pipe).
    * @return true se o pipe foi criado e aberto com sucesso, false caso contr�rio.
    */
    bool Create(const FIVR_PipeSettings& Settings, const FString& SessionID, int32 InWidth = 0, int32 InHeight = 0);

     /**
     * Tenta conectar-se ao Named Pipe. Este m�todo bloquear� at� que um cliente
     * (e.g., FFmpeg) se conecte ao pipe.
     * Deve ser chamado DEPOIS que o pipe � criado (com Create()) e DEPOIS que o cliente
     * que vai ler/escrever no pipe � lan�ado.
     * @return true se a conex�o foi bem-sucedida, false caso contr�rio.
     */
    bool Connect(); // <-- NOVO M�TODO

    /**
     * Escreve dados no pipe.
     * @param Data Ponteiro para os dados a serem escritos.
     * @param Size O n�mero de bytes a serem escritos.
     * @return O n�mero de bytes realmente escritos, ou -1 em caso de erro.
     */
    int32 Write(const uint8* Data, int32 NumBytes);

    /**
     * Fecha o pipe e libera seus recursos.
     * Para FIFOs POSIX, isso tamb�m remove o arquivo do sistema de arquivos.
     */
    void Close();

    /**
     * Verifica se o pipe est� aberto e v�lido.
     */
    bool IsValid() const;

    /**
     * Retorna o caminho completo do pipe (e.g., "\.\pipe\MyPipe" ou "/tmp/MyPipe").
     */
    FString GetFullPipeName() const;

private:

#if PLATFORM_WINDOWS
    HANDLE PipeHandle; // HANDLE para Windows Named Pipe
#elif PLATFORM_LINUX || PLATFORM_MAC
    int FileDescriptor; // Descritor de arquivo para FIFO POSIX
    int PipeHandle;     // Placeholder for non-Windows platforms
#endif

    FIVR_PipeSettings PipeSettings;

    FString FullPipePath; // Caminho completo para o pipe
    bool bIsCreatedAndConnected; // Indica se o pipe foi criado e est� pronto para uso

    // Desabilitar c�pia e atribui��o
    FIVR_PipeWrapper(const FIVR_PipeWrapper&) = delete;
    FIVR_PipeWrapper& operator=(const FIVR_PipeWrapper&) = delete;
};
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\IVR_PipeWrapper.h ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Components\IVRCaptureComponent.h ---
// D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Components\IVRCaptureComponent.h

#pragma once

#include "CoreMinimal.h"
#include "Components/SceneComponent.h"
#include "Core/IVRTypes.h"
// REMOVIDO: #include "../Audio/IVRAudioMixer.h" 

#include "Core/IVRFramePool.h"
#include "Recording/IVRFrameSource.h"
#include "Recording/IVRSimulatedFrameSource.h"
#include "Recording/IVRRenderFrameSource.h"
#include "Recording/IVRFolderFrameSource.h"
#include "Recording/IVRVideoFrameSource.h"
#include "Recording/IVRWebcamFrameSource.h"

#include "Engine/Texture2D.h" 
#include "Engine/TextureRenderTarget2D.h" 

#include "IVRCaptureComponent.generated.h"

class UIVRRecordingSession;

DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnIVRRecordingStarted);
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnIVRRecordingPaused);
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnIVRRecordingResumed);
DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnIVRRecordingStopped);

DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnRealTimeFrameReady, const FIVR_JustRTFrame&, FrameOutput);


UCLASS(ClassGroup=(IVR), meta=(BlueprintSpawnableComponent))
class IVR_API UIVRCaptureComponent : public USceneComponent 
{
    GENERATED_BODY()

public:
    UIVRCaptureComponent();
    virtual void BeginDestroy() override;

    // Recording Control
    UFUNCTION(BlueprintCallable, Category = "IVR")
    void StartRecording();

    UFUNCTION(BlueprintCallable, Category = "IVR")
    void StopRecording();

    UFUNCTION(BlueprintCallable, Category = "IVR")
    void PauseTake();

    UFUNCTION(BlueprintCallable, Category = "IVR")
    void ResumeTake();

    UFUNCTION(BlueprintPure, Category = "IVR")
    bool IsRecording() const { return bIsRecording; }

    // Settings
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video")
    FIVR_VideoSettings VideoSettings;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Takes")
    float TakeDuration = 5.0f;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Takes")
    bool bAutoStartNewTake = true;

    /**
     * @brief Prepara um arquivo de v�deo para grava��o, transcodificando-o para um formato compat�vel
     *        com o OpenCV, se necess�rio. O processo pode levar tempo e bloquear a thread.
     * @param InSourceVideoPath O caminho completo para o v�deo original.
     * @param OutPreparedVideoPath O caminho completo onde o v�deo preparado ser� salvo.
     * @param bOverwrite Se true, sobrescreve o arquivo de sa�da se ele j� existir.
     * @return O caminho completo do v�deo preparado se a transcodifica��o for bem-sucedida,
     *         uma string vazia caso contr�rio.
     */
    UFUNCTION(BlueprintCallable, Category = "IVR|Video Preparation",
              meta = (DisplayName = "Prepare Video for Recording",
                      ToolTip = "Transcodes a video file to a compatible format for OpenCV capture. Can be slow.",
                      DeterminesOutputType = "OutPreparedVideoPath"))
    FString PrepareVideoForRecording(const FString& InSourceVideoPath, const FString& OutPreparedVideoPath, bool bOverwrite = true);


    /**
     * @brief Transcodifica um v�deo existente para um formato mais amplamente compat�vel.
     *        �til para gerar uma vers�o para distribui��o ao usu�rio final a partir de um master otimizado.
     *        Pode levar tempo e bloquear a thread.
     * @param InSourceVideoPath O caminho completo para o v�deo de entrada (ex: o Master gerado).
     * @param OutCompatibleVideoPath O caminho completo onde o v�deo compat�vel ser� salvo.
     * @param bOverwrite Se true, sobrescreve o arquivo de sa�da se ele j� existir.
     * @param EncodingSettings As configura��es de v�deo para a transcodifica��o (codec, bitrate, etc.).
     * @return O caminho completo do v�deo compat�vel se a transcodifica��o for bem-sucedida,
     *         uma string vazia caso contr�rio.
     */
    UFUNCTION(BlueprintCallable, Category = "IVR|Video Export",
              meta = (DisplayName = "Export Video to Compatible Format",
                      ToolTip = "Transcodes an existing video to a more widely compatible format for end-user distribution.",
                      DeterminesOutputType = "OutCompatibleVideoPath"))
    FString ExportVideoToCompatibleFormat(const FString& InSourceVideoPath, const FString& OutCompatibleVideoPath, bool bOverwrite, const FIVR_VideoSettings& EncodingSettings);

    // Delegates para notifica��o de estados da grava��o (Proposta 02)
    UPROPERTY(BlueprintAssignable, Category = "IVR|Recording Events")
    FOnIVRRecordingStarted OnRecordingStarted;

    UPROPERTY(BlueprintAssignable, Category = "IVR|Recording Events")
    FOnIVRRecordingPaused OnRecordingPaused;

    UPROPERTY(BlueprintAssignable, Category = "IVR|Recording Events")
    FOnIVRRecordingResumed OnRecordingResumed;

    UPROPERTY(BlueprintAssignable, Category = "IVR|Recording Events")
    FOnIVRRecordingStopped OnRecordingStopped;

    // Delegate para notificar que um frame em tempo real est� pronto para coleta
    UPROPERTY(BlueprintAssignable, Category = "IVR|JustRTCapture Events")
    FOnRealTimeFrameReady OnRealTimeFrameReady;

    // Cor de tintura para o modo de captura em tempo real (JustRTCapture)
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video|JustRTCapture",
        meta = (EditCondition = "bEnableRTFrames", EditConditionHides, DisplayName = "Real-Time Display Tint"))
    FLinearColor RTDisplayTint = FLinearColor::White; 
    
protected:
    virtual void BeginPlay() override;
    virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;
    virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;

private:

    bool bIsRecording = false;
    
    UPROPERTY(Transient)
    UIVRRecordingSession* CurrentSession = nullptr;
    
    float CurrentTakeTime = 0.0f;
    int32 CurrentTakeNumber = 0;
    
    float RecordingStartTimeSeconds = 0.0f;

    UPROPERTY(Transient) 
    int32 ActualFrameWidth = 0;
    UPROPERTY(Transient)
    int32 ActualFrameHeight = 0;

    void StartNewTake();
    void EndCurrentTake();

    UPROPERTY(Transient)
    USceneCaptureComponent2D* OwnedVideoCaptureComponent;

    UPROPERTY(Transient)
    UIVRFramePool* FramePool;
    const int32 FramePoolSize = 60;

    UPROPERTY(Transient)
    UIVRFrameSource* CurrentFrameSource;

    UFUNCTION()
    void OnFrameAcquiredFromSource(FIVR_VideoFrame Frame);
    
    UPROPERTY(Transient)
    UTexture2D* RealTimeOutputTexture2D; 

    void UpdateTextureFromRawData(UTexture2D* Texture, const TArray<uint8>& RawData, int32 InWidth, int32 InHeight);
};
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Components\IVRCaptureComponent.h ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Core\IVRFramePool.h ---
#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "Containers/Queue.h"
#include "Templates/SharedPointer.h"
#include "Core/IVRTypes.h" // Para FIVR_VideoFrame e TArray<uint8>

#include "IVRFramePool.generated.h"

DECLARE_LOG_CATEGORY_EXTERN(LogIVRFramePool, Log, All);

/**
 * @brief Gerencia um pool de buffers de frames (TArray<uint8>) para reuso eficiente.
 * Acesso thread-safe garantido pela TQueue.
 */
UCLASS()
class IVR_API UIVRFramePool : public UObject
{
    GENERATED_BODY()

public:

    UIVRFramePool();
    virtual void BeginDestroy() override;

    /**
     * @brief Inicializa o pool de frames com um tamanho e dimens�es espec�ficos.
     * @param InPoolSize O n�mero inicial de buffers pr�-alocados no pool.
     * @param InFrameWidth A largura esperada dos frames.
     * @param InFrameHeight A altura esperada dos frames.
     * @param bForceReinitialize Se true, o pool ser� resetado e re-inicializado, mesmo que j� esteja inicializado.
     */
    void Initialize(int32 InPoolSize, int32 InFrameWidth, int32 InFrameHeight, bool bForceReinitialize = false);

    /**
     * @brief Libera um buffer de frame, retornando-o ao pool para reuso.
     * @param FrameBuffer O TSharedPtr para o buffer do frame a ser liberado.
     */
    void ReleaseFrame(TSharedPtr<TArray<uint8>> FrameBuffer);

    /**
     * @brief Adquire um buffer de frame do pool. Se o pool estiver vazio, um novo buffer � criado.
     * @return Um TSharedPtr para um TArray<uint8> que representa o buffer do frame.
     */
    TSharedPtr<TArray<uint8>> AcquireFrame();

    /**
     * @brief Retorna se o pool est� inicializado.
     */
    bool IsInitialized() const { return bIsInitialized; }

    /**
     * @brief Retorna a largura dos frames que o pool est� configurado para gerenciar.
     */
    int32 GetFrameWidth() const { return FrameWidth; }

    /**
     * @brief Retorna a altura dos frames que o pool est� configurado para gerenciar.
     */
    int32 GetFrameHeight() const { return FrameHeight; }

private:

    TQueue<TSharedPtr<TArray<uint8>>> FrameBufferPool;
    int32 PoolSize;
    int32 FrameWidth;
    int32 FrameHeight;
    int32 FrameBufferSize; // Tamanho total em bytes de um frame (Width * Height * 4 para BGRA)

    bool bIsInitialized = false;
};
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Core\IVRFramePool.h ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Core\IVRTypes.h ---
// D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Core\IVRTypes.h

#pragma once

#include "CoreMinimal.h"
#include "IVRTypes.generated.h"

// NOVO: Enum para definir o tipo de fonte de frames
UENUM(BlueprintType)
enum class EIVRFrameSourceType : uint8
{
    Simulated       UMETA(DisplayName = "Simulated Frames"),
    RenderTarget    UMETA(DisplayName = "Render Target Capture"),
    Folder          UMETA(DisplayName = "Image Folder"),
    VideoFile       UMETA(DisplayName = "Video File"),
    Webcam          UMETA(DisplayName = "Webcam")
};

USTRUCT(BlueprintType)
struct IVR_API FIVR_VideoSettings
{
    GENERATED_BODY()

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings")
    int32 Width = 1920;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings")
    int32 Height = 1080;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings")
    float FPS = 30.0f;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings")
    FString Codec = TEXT("H264");// Ex: h264, vp9, etc.

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings")
    int32 Bitrate = 5000000; // Em bps (bits por segundo), ex: 5 Mbps

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings")
    FString PixelFormat = TEXT("bgra"); // FFmpeg pixel format (e.g., bgra for raw frame input)

    // NOVO: Seleo do tipo de fonte de frames
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings")
    EIVRFrameSourceType FrameSourceType = EIVRFrameSourceType::RenderTarget; // Default para captura real

    // NOVO: Categoria e flag para JustRTCapture
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings|JustRTCapture",
        meta = (DisplayName = "Enable Real-Time Frame Output", ToolTip = "Quando verdadeiro, os frames capturados so disponibilizados em tempo real via delegate, em vez de serem enviados para gravao FFmpeg. Ideal para integrao com UI ou manipulao de pixels."))
    bool bEnableRTFrames = false;

    // NOVO: Ator a ser seguido pela cmera
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings|Camera Follow")
    class AActor* IVR_FollowActor = nullptr;

    // --- Parmetros para UIVRFolderFrameSource ---
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings|Folder Frame Source",
        meta = (EditCondition = "FrameSourceType == EIVRFrameSourceType::Folder", EditConditionHides))
    FString IVR_FramesFolder;
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings|Folder Frame Source",
        meta = (EditCondition = "FrameSourceType == EIVRFrameSourceType::Folder", EditConditionHides))
    float IVR_FolderPlaybackFPS = 30.0f;
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings|Folder Frame Source",
        meta = (EditCondition = "FrameSourceType == EIVRFrameSourceType::Folder", EditConditionHides))
    bool IVR_LoopFolderPlayback = true;

    // --- Parmetros para UIVRRenderFrameSource (Configuraes de Cmera Cinemtica) ---
    // NOTA: Estas configura��es ser�o aplicadas ao USceneCaptureComponent2D ou a um UCineCameraComponent
    // se o UIVRCaptureComponent estiver anexado a um ator com um CineCameraComponent.
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings|Render Frame Source",
        meta = (EditCondition = "FrameSourceType == EIVRFrameSourceType::RenderTarget", EditConditionHides))
    float IVR_CineCameraFOV = 90.0f; // Campo de Viso
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings|Render Frame Source",
        meta = (EditCondition = "FrameSourceType == EIVRFrameSourceType::RenderTarget", EditConditionHides))
    float IVR_CineCameraFocalLength = 50.0f; // Distncia Focal (apenas para UCineCameraComponent)
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings|Render Frame Source",
        meta = (EditCondition = "FrameSourceType == EIVRFrameSourceType::RenderTarget", EditConditionHides))
    float IVR_CineCameraAperture = 2.8f; // Abertura (apenas para UCineCameraComponent)
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings|Render Frame Source",
        meta = (EditCondition = "FrameSourceType == EIVRFrameSourceType::RenderTarget", EditConditionHides))
    float IVR_CineCameraFocusDistance = 1000.0f; // Distncia de Foco (apenas para UCineCameraComponent)
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings|Render Frame Source",
        meta = (EditCondition = "FrameSourceType == EIVRFrameSourceType::RenderTarget", EditConditionHides))
    bool IVR_EnableCinematicPostProcessing = true; // Flag para habilitar ou desabilitar ps-processamento da cmera

    // --- Parmetros para UIVRVideoFrameSource (Arquivo de Vdeo Generalizado) ---
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings|Video File Source",
        meta = (EditCondition = "FrameSourceType == EIVRFrameSourceType::VideoFile", EditConditionHides))
    FString IVR_VideoFilePath;
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings|Video File Source",
        meta = (EditCondition = "FrameSourceType == EIVRFrameSourceType::VideoFile", EditConditionHides))
    float IVR_VideoPlaybackSpeed = 1.0f;
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings|Video File Source",
        meta = (EditCondition = "FrameSourceType == EIVRFrameSourceType::VideoFile", EditConditionHides))
    bool IVR_LoopVideoPlayback = true;

    // --- Parmetros para UIVRWebcamFrameSource ---
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings|Webcam Frame Source",
        meta = (EditCondition = "FrameSourceType == EIVRFrameSourceType::Webcam", EditConditionHides))
    int32 IVR_WebcamIndex = 0; // 0 para padro, 1 para segunda, etc.
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings|Webcam Frame Source",
        meta = (EditCondition = "FrameSourceType == EIVRFrameSourceType::Webcam", EditConditionHides))
    FVector2D IVR_WebcamResolution = FVector2D(1280.0f, 720.0f); // Resoluo desejada (largura x altura)
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings|Webcam Frame Source",
        meta = (EditCondition = "FrameSourceType == EIVRFrameSourceType::Webcam", EditConditionHides))
    float IVR_WebcamFPS = 30.0f;

    // Cor de tintura para frames gerados pela fonte (ex: Simulated)
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings")
    FLinearColor IVR_FrameTint = FLinearColor::White; 
    // Padrao randomico de tempo para altera��o da cor
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Video Settings|Simulated Frame Source",
        meta = (EditCondition = "FrameSourceType == EIVRFrameSourceType::Simulated", EditConditionHides))
    bool IVR_UseRandomPattern = true;
};

// Estrutura para os dados de sa�da de frames em tempo real
USTRUCT(BlueprintType)
struct IVR_API FIVR_JustRTFrame
{
    GENERATED_BODY()

    // Refer�ncia direta ao RenderTarget interno usado pelo UIVRRenderFrameSource.
    UPROPERTY(BlueprintReadOnly, Category = "JustRTFrame Output")
    UTextureRenderTarget2D* RenderTarget; 

    // UTexture2D dinamicamente atualizada com os pixels do frame.
    UPROPERTY(BlueprintReadOnly, Category = "JustRTFrame Output")
    UTexture2D* LiveTexture; 

    // Dados brutos de pixel do frame (BGRA).
    UPROPERTY(BlueprintReadOnly, Category = "JustRTFrame Output")
    TArray<uint8> RawDataBuffer; 

    UPROPERTY(BlueprintReadOnly, Category = "JustRTFrame Output")
    int32 Width;

    UPROPERTY(BlueprintReadOnly, Category = "JustRTFrame Output")
    int32 Height;

    UPROPERTY(BlueprintReadOnly, Category = "JustRTFrame Output")
    float Timestamp; // Tempo de captura do frame

    UPROPERTY(BlueprintReadOnly, Category = "JustRTFrame Output") // Tintura aplicada pelo IVRCaptureComponent
    FLinearColor DisplayTint; 

    UPROPERTY(BlueprintReadOnly, Category = "JustRTFrame Output") // Tintura original da fonte (FIVR_VideoSettings)
    FLinearColor SourceFrameTint; 
};


USTRUCT(BlueprintType)
struct IVR_API FIVR_TakeInfo
{
    GENERATED_BODY()

    UPROPERTY(BlueprintReadOnly)
    int32 TakeNumber = 0;

    UPROPERTY(BlueprintReadOnly)
    float Duration = 0.0f;

    UPROPERTY(BlueprintReadOnly)
    FDateTime StartTime;

    UPROPERTY(BlueprintReadOnly)
    FDateTime EndTime;

    UPROPERTY(BlueprintReadOnly)
    FString FilePath;

    UPROPERTY(BlueprintReadOnly)
    FString SessionID; 
};

USTRUCT(BlueprintType)
struct IVR_API FIVR_VideoFrame
{
    GENERATED_BODY()

    TSharedPtr<TArray<uint8>> RawDataPtr; 

    UPROPERTY(VisibleAnywhere, Category = "Video Frame Data")
    int32 Width; // Width of the frame

    UPROPERTY(VisibleAnywhere, Category = "Video Frame Data")
    int32 Height; // Height of the frame

    UPROPERTY(VisibleAnywhere, Category = "Video Frame Data")
    float Timestamp; // Time when the frame was generated/captured (in seconds)

    // Construtor padro
    FIVR_VideoFrame()
        : Width(0)
        , Height(0)
        , Timestamp(0.0f)
    {}

    // Construtor para facilitar a criao
    FIVR_VideoFrame(int32 InWidth, int32 InHeight, float InTimestamp)
        : Width(InWidth)
        , Height(InHeight)
        , Timestamp(InTimestamp)
    {}
};

/**
 * Estrutura para configura��es globais de Named Pipes.
 * Esta estrutura pode ser usada para configurar Named Pipes criados ou acessados pelo plugin IVR.
 */
USTRUCT(BlueprintType)
struct IVR_API FIVR_PipeSettings
{
    GENERATED_BODY()

    /** O nome base do pipe. O path completo ser� constru�do usando \.\pipe\<BasePipeName> */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Pipe Settings")
    FString BasePipeName = TEXT("UnrealRecordingPipe");

    /**
     * Se true, esta inst�ncia ser� o "servidor" do pipe (o criador que aguarda conex�es).
     * Se false, esta inst�ncia tentar� se conectar a um pipe existente (como cliente).
     */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Pipe Settings")
    bool bIsServerPipe = true;

    /**
     * Se true, o pipe permitir� comunica��o bidirecional (leitura e escrita).
     * Se false, o pipe permitir� apenas acesso de sa�da (escrita) para o servidor.
     * (Equivale a PIPE_ACCESS_DUPLEX se true, ou PIPE_ACCESS_OUTBOUND se false, para o servidor).
     */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Pipe Settings")
    bool bDuplexAccess = false;

    /**
     * Se true, as opera��es de leitura/escrita no pipe ser�o bloqueantes (sincronizadas).
     * A thread que chama a opera��o aguardar� at� que ela seja conclu�da.
     * (Equivale a PIPE_WAIT se true, ou PIPE_NOWAIT se false).
     */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Pipe Settings")
    bool bBlockingMode = true;

    /**
     * Se true, o pipe operar� em modo de mensagem, onde dados s�o lidos/escritos como blocos discretos.
     * Se false, o pipe operar� em modo de byte, onde dados s�o lidos/escritos como um fluxo cont�nuo.
     * (Equivale a PIPE_TYPE_MESSAGE se true, ou PIPE_TYPE_BYTE se false).
     */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Pipe Settings")
    bool bMessageMode = false;

    /**
     * O n�mero m�ximo de inst�ncias que podem ser criadas para este pipe.
     * Defina como -1 para PIPE_UNLIMITED_INSTANCES (limitado a 255 pelo Windows).
     */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Pipe Settings",
        meta = (ClampMin = "-1", ClampMax = "255", UIMin = "-1", UIMax = "255")) // Sugest�o para UI do Blueprint
        int32 MaxInstances = -1;

    /**
     * O tamanho sugerido do buffer de sa�da do pipe em bytes.
     * O Windows pode ajustar este valor.
     */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Pipe Settings")
    int32 OutBufferSize = 65536; // 64 KB

    /**
     * O tamanho sugerido do buffer de entrada do pipe em bytes.
     * O Windows pode ajustar este valor.
     */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Pipe Settings")
    int32 InBufferSize = 65536; // 64 KB
};
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Core\IVRTypes.h ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Recording\IVRECFactory.h ---
// Fill out your copyright notice in the Description page of Project Settings.
#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "Core/IVRTypes.h"
#include "IVRECFactory.generated.h"

DECLARE_LOG_CATEGORY_EXTERN(LogIVRECFactory, Log, All);

UCLASS(Blueprintable, BlueprintType, meta=(DisplayName="IVR Encoder Command Factory"))
class IVR_API UIVRECFactory : public UObject
{
    GENERATED_BODY()

public:
    // Construtor padr�o da classe
    UIVRECFactory();

    // Map para armazenar os formatos dos comandos do FFmpeg
    // Chave: Nome do comando (e.g., "RecordRawFrame")
    // Valor: String de formato com placeholders para FString::Format (e.g., "-f s16le -ar {0} -ac {1} -i "{2}"")
    // 'VisibleAnywhere' permite visualizar e 'EditDefaultsOnly' permite editar no Blueprint Defaults
    UPROPERTY(EditDefaultsOnly, Category = "FFmpeg Encoder")
    TMap<FString, FString> EncoderCommandFormats;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Recording Settings")
    FIVR_VideoSettings VideoSettings;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Recording Settings")
    FIVR_PipeSettings VideoPipeConfig;

    /**
     * Retorna uma string de comando FFmpeg formatada com base no nome do comando e uma lista de argumentos.
     * Os argumentos devem ser passados como um array de strings.
     * O formato esperado na string de comando usa placeholders como {0}, {1}, etc.
     *
     * @param CommandName O nome do comando a ser formatado (e.g., "RecordRawFrame").
     * @param FormatterArgs Um array de strings com os valores a serem inseridos nos placeholders.
     *        Por exemplo, para "RecordRawFrame" (-f s16le -ar {0} -ac {1} -i "{2}"),
     *        FormatterArgs deve ser: ["<SampleRate>", "<NumChannels>", "<AudioPipePath>"].
     * @return A string de comando FFmpeg formatada, ou uma string vazia se o comando n�o for encontrado.
     */
    UFUNCTION(BlueprintCallable, Category = "FFmpeg Encoder|Commands")
    FString IVR_GetEncoderCommand(const FString& CommandName);

    void IVR_SetInPipePath    (FString InVideoPipe) { InVideoPipePath = InVideoPipe; }
    void IVR_SetOutputFilePath(FString OutVideoFile) { InOutputFilePath = OutVideoFile; }
    void IVR_SetExecutablePath(const FString& InFFmpegExecutablePath) { FFmpegExecutablePath = InFFmpegExecutablePath; }
    void IVR_SetVideoSettings (const FIVR_VideoSettings& InVideoSettings) { VideoSettings = InVideoSettings; }
    void IVR_SetActualVideoDimensions(int32 InWidth, int32 InHeight) { ActualVideoWidth = InWidth; ActualVideoHeight = InHeight; }
    void IVR_SetPipeSettings  ();
    
    void IVR_SetProducerPipePath    (FString InPipePath) { ProducerPipePath = InPipePath; }
    void IVR_SetConsumerPipePath    (FString InPipePath) { ConsumerPipePath = InPipePath; }
   
    FIVR_PipeSettings  IVR_GetPipeSettings ();
    FIVR_VideoSettings IVR_GetVideoSettings();
    bool               IVR_GetExecFPath(FString &pIVR_ExecutablePath);
    FString            IVR_GetProducerPath();
    FString            IVR_GetConsumerPath();

    /**
    * Build FFmpeg Command using Raw definitions. Usefull to just test file generation.
    */
    void IVR_BuildRawRgbCommand();

    /**
    * Build FFmpeg Command using Libx264 with ultrafast preset.
    * This command now expects InVideoPipePath and InOutputFilePath to be set.
    */
    void IVR_BuildLibx264Command();

    /**
    * Build FFmpeg Command using The IVR Settings Codec and BitRate Info.
    */
    void IVR_BuildSettingsCommand();

    void IVR_BuildReadFrameCommand();

    /**
     * @brief Builds an FFmpeg command for concatenating video files using the concat demuxer.
     * @param InFilelistPath Path to the temporary file containing the list of videos to concatenate.
     * @param InMasterOutputPath Path for the final concatenated "Master" video file.
     */
    void IVR_BuildConcatenationCommand(const FString& InFilelistPath, const FString& InMasterOutputPath);


protected:

    // Fun��o auxiliar para adicionar formatos de comando (usada no construtor)
    void IVR_AddCommandFormat(const FString& Name, const FString& Format);

    FString InVideoPipePath;
    FString InOutputFilePath;

    FString FFmpegExecutablePath;           // Caminho para o execut�vel do FFmpeg

    FString ProducerPipePath;
    FString ConsumerPipePath;

    // Armazena a largura e altura reais que a FFmpeg deve usar para o stream de entrada
    int32 ActualVideoWidth;
    int32 ActualVideoHeight;
};
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Recording\IVRECFactory.h ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Recording\IVRFolderFrameSource.h ---
#pragma once

#include "CoreMinimal.h"
#include "Recording/IVRFrameSource.h"
#include "ImageUtils.h" // Necess�rio para FImageUtils
#include "IImageWrapper.h" // Necess�rio para IImageWrapper
#include "IImageWrapperModule.h" // Necess�rio para IImageWrapperModule
#include "IVRFolderFrameSource.generated.h"

UCLASS(Blueprintable, BlueprintType, meta=(DisplayName="IVR Folder Frame Source"))
class IVR_API UIVRFolderFrameSource : public UIVRFrameSource
{
    GENERATED_BODY()

public:
    UIVRFolderFrameSource();

    virtual void Initialize(UWorld* World, const FIVR_VideoSettings& Settings, UIVRFramePool* InFramePool) override;
    virtual void Shutdown() override;
    virtual void StartCapture() override;
    virtual void StopCapture() override;

protected:
    FTimerHandle FrameReadTimerHandle;
    TArray<FString> ImageFiles;
    int32 CurrentImageIndex;

    void ReadNextFrameFromFile();
    bool LoadImageFromFile(const FString& FilePath, TArray<uint8>& OutRawData);

private:

    TSharedPtr<IImageWrapper> GetImageWrapperByExtention(FString InImagePath);

};
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Recording\IVRFolderFrameSource.h ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Recording\IVRFrameSource.h ---
#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "Core/IVRTypes.h"
#include "Core/IVRFramePool.h" // Inclua o pool de frames

#include "IVRFrameSource.generated.h"

DECLARE_LOG_CATEGORY_EXTERN(LogIVRFrameSource, Log, All);

// NOVO: Delegate multicast para notificar sobre novos frames adquiridos
DECLARE_MULTICAST_DELEGATE_OneParam(FOnFrameAcquiredDelegate, FIVR_VideoFrame /*Frame*/);

/**
 * @brief Classe base abstrata para fontes de frames. Define a interface polim�rfica.
 */
UCLASS(Blueprintable, Abstract)
class IVR_API UIVRFrameSource : public UObject
{
    GENERATED_BODY()

public:
    UIVRFrameSource();
    virtual void BeginDestroy() override;

    /**
     * @brief Inicializa a fonte de frames. Deve ser implementada por classes derivadas.
     * @param World O UWorld atual, necess�rio para gerenciar timers ou acessar componentes.
     * @param Settings As configura��es de v�deo, incluindo dimens�es e FPS.
     * @param InFramePool O pool de frames para adquirir e liberar buffers.
     */
    UFUNCTION(BlueprintCallable, Category = "IVR|FrameSource")
    virtual void Initialize(UWorld* World, const FIVR_VideoSettings& Settings, UIVRFramePool* InFramePool) PURE_VIRTUAL(Initialize);

    /**
     * @brief Desliga a fonte de frames e libera seus recursos. Deve ser implementada por classes derivadas.
     */
    UFUNCTION(BlueprintCallable, Category = "IVR|FrameSource")
    virtual void Shutdown() PURE_VIRTUAL(Shutdown);

    /**
     * @brief Inicia a captura/gera��o de frames. Deve ser implementada por classes derivadas.
     */
    UFUNCTION(BlueprintCallable, Category = "IVR|FrameSource")
    virtual void StartCapture() PURE_VIRTUAL(StartCapture);

    /**
     * @brief Para a captura/gera��o de frames. Deve ser implementada por classes derivadas.
     */
    UFUNCTION(BlueprintCallable, Category = "IVR|FrameSource")
    virtual void StopCapture() PURE_VIRTUAL(StopCapture);

    /** Delegate para o qual as classes consumidoras se ligar�o para receber frames. */
    FOnFrameAcquiredDelegate OnFrameAcquired;

protected:
    UPROPERTY(Transient)
    UWorld* CurrentWorld;

    UPROPERTY(Transient)
    FIVR_VideoSettings FrameSourceSettings;

    UPROPERTY(Transient)
    UIVRFramePool* FramePool;

    // Helper para adquirir um frame do pool e configurar as dimens�es b�sicas
    TSharedPtr<TArray<uint8>> AcquireFrameBufferFromPool();
};
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Recording\IVRFrameSource.h ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Recording\IVRRecordingManager.h ---
#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "Core/IVRTypes.h" 

#include "IVRRecordingManager.generated.h"

class UIVRRecordingSession;
class UIVRVideoEncoder; 
// REMOVIDO: class UIVRAudioCaptureSystem; 
class UIVRFramePool; 

UCLASS()
class IVR_API UIVRRecordingManager : public UObject
{
    GENERATED_BODY()

public:
    static UIVRRecordingManager* Get();

    UFUNCTION(BlueprintCallable, Category = "IVR")
    UIVRRecordingSession* StartRecording(const FIVR_VideoSettings& VideoSettings, int32 pActualFrameWidth, int32 pActualFrameHeight, UIVRFramePool* InFramePool);

    UFUNCTION(BlueprintCallable, Category = "IVR")
    void StopRecording(UIVRRecordingSession* Session);

    UFUNCTION(BlueprintCallable, Category = "IVR")
    void FinalizeAllRecordings(FString MasterVideoPath, const FIVR_VideoSettings& VideoSettings, const FString& FFmpegExecutablePath);

    UFUNCTION(BlueprintCallable, Category = "IVR")
    TArray<FIVR_TakeInfo> GetAllTakes() const;

    UFUNCTION(BlueprintCallable, Category = "IVR")
    void ClearAllTakes();

    UFUNCTION(BlueprintCallable, Category = "IVR|Recording")
    FString GenerateMasterVideoAndCleanup();

    // TORNANDO LaunchFFmpegProcessBlocking P�BLICA PARA ACESSO EXTERNO VIA SINGLETON
    // (UIVRCaptureComponent precisar� cham�-la)
    bool LaunchFFmpegProcessBlocking(const FString& ExecPath, const FString& Arguments);

private:
    static UIVRRecordingManager* Instance;
    
    UPROPERTY()
    TArray<UIVRRecordingSession*> ActiveSessions;

    UPROPERTY()
    TArray<FIVR_TakeInfo> CompletedTakes;

    // REMOVIDO: UPROPERTY() UIVRAudioCaptureSystem* AudioCapture; 

    UPROPERTY()
    UIVRVideoEncoder* UtilityVideoEncoder; 

    void Initialize();
    void Cleanup();

    UPROPERTY()
    FString MasterVideoFilePath;

    FString BuildFFmpegConcatCommand(const TArray<FString>& TakeFilePaths, const FString& OutputMasterPath);
    
    void CleanupIndividualTakes();

};
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Recording\IVRRecordingManager.h ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Recording\IVRRecordingSession.h ---
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "HAL/Runnable.h"
#include "HAL/RunnableThread.h"
#include "Core/IVRTypes.h"
// REMOVIDO: #include "../Audio/IVRAudioMixer.h" // Se IVRAudioMixer.h � necess�rio
#include "Containers/Queue.h"
#include "Misc/Guid.h"
#include "Misc/Paths.h"
#include "HAL/PlatformFileManager.h"
#include "HAL/FileManager.h"
#include "../IVRGlobalStatics.h"
#include "../IVR_PipeWrapper.h" 
#include "IVRVideoEncoder.h" // Inclui o novo encoder centralizado
#include "Core/IVRFramePool.h" // Adicionar este include!

#include "IVRRecordingSession.generated.h"

// Definir um LogCategory para mensagens espec�ficas da grava��o IVR
DECLARE_LOG_CATEGORY_EXTERN(LogIVRRecSession, Log, All);

/**
 * Classe respons�vel por gerenciar uma �nica sess�o de grava��o de um take de v�deo.
 * Ela orquestra a captura de frames e delega a codifica��o ao UIVRVideoEncoder.
 */
UCLASS(BlueprintType)
class IVR_API UIVRRecordingSession : public UObject, public FRunnable
{
    GENERATED_BODY()

public:

    UIVRRecordingSession();
    virtual ~UIVRRecordingSession();

     /**
    * Inicializa a sess�o de grava��o.
    * @param InVideoSettings Configura��es de v�deo.
    * @param InFFmpegExecutablePath Caminho completo para o execut�vel ffmpeg.exe.
    * @param InActualFrameWidth Largura real dos frames.
    * @param InActualFrameHeight Altura real dos frames.
    * @param InFramePool Refer�ncia ao pool de frames para gerenciamento de buffers. 
    */
    void Initialize(const FIVR_VideoSettings& InVideoSettings, const FString& InFFmpegExecutablePath, int32 InActualFrameWidth, int32 InActualFrameHeight, UIVRFramePool* InFramePool); 

    /**
     * @brief Inicia a grava��o do take de v�deo.
     * @return true se a grava��o foi iniciada com sucesso, false caso contr�rio.
     */
    UFUNCTION(BlueprintCallable, Category = "IVR|Recording")
    bool StartRecording();

    /**
     * @brief Para a grava��o do take de v�deo e finaliza o arquivo.
     */
    UFUNCTION(BlueprintCallable, Category = "IVR|Recording")
    void StopRecording();

    /**
     * @brief Pausa a grava��o do take de v�deo.
     */
    UFUNCTION(BlueprintCallable, Category = "IVR|Recording")
    void PauseRecording();

    /**
     * @brief Retoma a grava��o do take de v�deo.
     */
    UFUNCTION(BlueprintCallable, Category = "IVR|Recording")
    void ResumeRecording();

    UFUNCTION(BlueprintPure, Category = "IVR")
    bool IsRecording() const { return bIsRecording; }

    UFUNCTION(BlueprintPure, Category = "IVR")
    bool IsPaused() const { return bIsPaused; }

    UFUNCTION(BlueprintPure, Category = "IVR")
    float GetDuration() const;

    UFUNCTION(BlueprintCallable, Category = "IVR")
    void ClearQueues();

    UFUNCTION(BlueprintPure, Category = "IVR")
    FDateTime GetStartTime() const { return StartTime; }

    /**
     * @brief Retorna o caminho do arquivo do take gravado por esta sess�o.
     * Ser� v�lido ap�s o StopRecording bem-sucedido.
     */
    UFUNCTION(BlueprintPure, Category = "IVR")
    FString GetOutputPath() const { return CurrentTakeFilePath; } 

    /**
     * @brief Retorna o o Session ID da grava��o.
     * Ser� v�lido ap�s o StopRecording bem-sucedido.
     */
    UFUNCTION(BlueprintPure, Category = "IVR")
    FString GetSessionID() const { return SessionID; } 

    /**
     * @brief Adiciona um frame de v�deo � fila para ser processado pelo encoder.
     * @param Frame O frame FIVR_VideoFrame (com TSharedPtr) a ser adicionado.
     */
    void AddVideoFrame(FIVR_VideoFrame Frame); // Assinatura mudada para receber por valor
    
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Recording Settings")
    FIVR_VideoSettings UserRecordingSettings;

    int32 GetConsumerQCounter() { return VideoConsumerQCounter; }
    int32 GetProducerQCounter() { return VideoProducerQCounter; }

private:
    // Refer�ncia ao codificador de v�deo, que agora gerencia o FFmpeg.
    UPROPERTY()
    UIVRVideoEncoder* VideoEncoder;

    FThreadSafeBool bIsRecording = false; 
    FThreadSafeBool bIsPaused = false;    
    
    FDateTime StartTime;
    float RecordingDuration = 0.0f;
    
    FString SessionID; // ID �nico para este take.

    // Caminho do arquivo do take individual que est� sendo gravado por esta sess�o.
    FString CurrentTakeFilePath;      
    
    // Fila para frames do thread principal (produtor) para o worker thread (consumidor).
    TQueue<FIVR_VideoFrame, EQueueMode::Mpsc> VideoFrameProducerQueue; 
    
    // Contadores para monitoramento da fila de frames de v�deo.
    int32 VideoProducerQCounter = 0;
    int32 VideoConsumerQCounter = 0;

    /**
    * @brief Gera o caminho completo para o arquivo de take desta sess�o.
    * Ser� chamado uma vez durante a inicializa��o/start.
    */
    FString GenerateTakeFilePath(); 

    /**
    * Gera o caminho completo para o arquivo de v�deo Master.
    * Utiliza o Timestamp e o SessionID desta sess�o.
    */
    FString GenerateMasterFilePath() const;

    // --- Membros para o FRunnable (thread de grava��o de frames) ---
    FRunnableThread* RecordingThread;       // Thread de grava��o dedicado
    FThreadSafeBool bStopThread = false;    // Flag para sinalizar o encerramento do thread
    FEvent* HasNewFrameEvent;               // Evento para sinalizar novos frames para o thread de grava��o

    // --- Implementa��o da Interface FRunnable ---
    virtual bool Init() override;
    virtual uint32 Run() override;
    virtual void Stop() override;
    virtual void Exit() override;

    UPROPERTY()
    UIVRFramePool* FramePool; // Refer�ncia ao pool de frames para liberar buffers 
};
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Recording\IVRRecordingSession.h ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Recording\IVRRenderFrameSource.h ---
#pragma once

#include "CoreMinimal.h"
#include "Recording/IVRFrameSource.h"
#include "Components/SceneCaptureComponent2D.h"
#include "Engine/TextureRenderTarget2D.h"
#include "Framework/Application/SlateApplication.h" 
#include "RenderGraphBuilder.h"         
#include "RenderingThread.h"            
#include "RenderUtils.h"                
#include "HAL/ThreadSafeCounter.h"      // Para o mecanismo de "locked rendering"
#include "Containers/Queue.h"           // Para a fila de render requests
#include "CineCameraComponent.h"

#include "IVRRenderFrameSource.generated.h"

DECLARE_LOG_CATEGORY_EXTERN(LogIVRRenderFrameSource, Log, All);

/**
 * @brief Estrutura interna para gerenciar requisies de renderizao.
 */
struct FRenderRequestInternal
{
    TSharedPtr<TArray<FColor>> ImageBuffer; // Buffer para ler FColor da GPU
    FRenderCommandFence RenderFence;        // Fence para sincronizao com a GPU

    FRenderRequestInternal() : ImageBuffer(MakeShared<TArray<FColor>>()) {}
};

/**
 * @brief Fonte de frames que captura a sada de renderizao do Unreal Engine.
 * Incorpora a lgica de fila e "locked rendering" do exemplo AIVR_FrameSource.
 */
UCLASS(Blueprintable, BlueprintType, meta = (DisplayName = "IVR Render Frame Source"))
class IVR_API UIVRRenderFrameSource : public UIVRFrameSource
{
    GENERATED_BODY()

public:
    UIVRRenderFrameSource();
    virtual void BeginDestroy() override;

    /**
     * @brief Inicializa a fonte de frames.
     * @param World O UWorld atual.
     * @param Settings As configuraes de vdeo.
     * @param InFramePool O pool de frames.
     * @param InVideoCaptureComponent O SceneCaptureComponent2D a ser usado para a captura.
     */
    virtual void Initialize(UWorld* World, const FIVR_VideoSettings& Settings, UIVRFramePool* InFramePool) override;
    
    // Overload para aceitar um VideoCaptureComponent existente
    void Initialize(UWorld* World, const FIVR_VideoSettings& Settings, UIVRFramePool* InFramePool, USceneCaptureComponent2D* InVideoCaptureComponent);

    virtual void Shutdown() override;
    virtual void StartCapture() override;
    virtual void StopCapture() override;

    /**
     * @brief Processa a fila de requisies de renderizao pendentes.
     * Esta funo deve ser chamada periodicamente na Game Thread (ex: do TickComponent do IVRCaptureComponent).
     */
    void ProcessRenderQueue();

    // NOVO: Getter para o RenderTarget interno.
    UTextureRenderTarget2D* GetRenderTarget() const { return VideoRenderTarget; } 

protected:

    UPROPERTY(Transient)
    USceneCaptureComponent2D* VideoCaptureComponent; 

    UPROPERTY(Transient)
    UTextureRenderTarget2D* VideoRenderTarget;

    FDelegateHandle OnBackBufferReadyToPresentHandle;

    // Fila para requisies de renderizao (render thread -> game thread)
    TQueue<TSharedPtr<FRenderRequestInternal>> RenderRequestQueue;
    int32 RReqQueueCounter = 0;

    // Flag para controlar a cadncia de captura da Render Thread (similar ao IVR_LockedRendering)
    // 0 = Locked (no captura), 1 = Unlocked (pode capturar)
    FThreadSafeCounter bCanCaptureNextFrame; 

    /**
     * @brief Callback que  chamado na Render Thread quando o back buffer est pronto.
     * Ir disparar a leitura do RenderTarget e enfileirar a requisio.
     */
    void OnBackBufferReady(SWindow& SlateWindow, const FTextureRHIRef& BackBuffer);

    /**
     * @brief Converte dados RGBA (FColor) para BGRA (uint8) e copia para o buffer do pool.
     * @param InColors O array de FColors a ser convertido.
     * @param OutBuffer O TArray<uint8> de sada onde os dados BGRA sero copiados.
     */
    void ConvertRgbaToBgraAndCopyToBuffer(const TArray<FColor>& InColors, TArray<uint8>& OutBuffer);
};
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Recording\IVRRenderFrameSource.h ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Recording\IVRSimulatedFrameSource.h ---
// IVRSimulatedFrameSource.h

#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "TimerManager.h" // Para FTimerHandle e FTimerManager
#include "Core/IVRTypes.h" // Para FIVR_VideoFrame
#include "Recording/IVRFrameSource.h" // NOVO: Deriva da classe base


#include "IVRSimulatedFrameSource.generated.h"


UCLASS(Blueprintable, BlueprintType, meta=(DisplayName="IVR Simulated Frame Source"))
class IVR_API UIVRSimulatedFrameSource  : public UIVRFrameSource // NOVO: Deriva de UIVRFrameSource
{
    GENERATED_BODY()

public:
    UIVRSimulatedFrameSource();
     virtual void BeginDestroy() override;

    /**
     * @brief Inicializa o gerador de frames simulados.
     * @param World O ponteiro para o UWorld, necessrio para acessar o TimerManager.
     * @param Settings As configuraes de vdeo, incluindo dimenses e FPS.
     * @param InFramePool O pool de frames para adquirir e liberar buffers.
     */
    //UFUNCTION(BlueprintCallable, Category = "IVR|SimulatedFrames")
    virtual void Initialize(UWorld* World, const FIVR_VideoSettings& Settings, UIVRFramePool* InFramePool) override; // Implementa base
    
    // NOVO: Overload para incluir a tintura
    void Initialize(UWorld* World, const FIVR_VideoSettings& Settings, UIVRFramePool* InFramePool, FLinearColor InFrameTint); // NOVO


    /**
     * @brief Inicia a gerao de frames simulados.
     */
    //UFUNCTION(BlueprintCallable, Category = "IVR|SimulatedFrames")
    virtual void StartCapture() override; // Implementa base

    /**
     * @brief Para a gerar de frames simulados.
     */
    //UFUNCTION(BlueprintCallable, Category = "IVR|SimulatedFrames")
    virtual void Shutdown() override; // Implementa base
    
    //UFUNCTION(BlueprintCallable, Category = "IVR|SimulatedFrames")
    virtual void StopCapture() override; // Implementa base

protected:

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|SimulatedFrames")
    float FrameRate = 30.0f; // Frequncia de gerao de frames em FPS

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|SimulatedFrames")
    int32 FrameWidth = 1920; // Largura padro do frame simulado

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|SimulatedFrames")
    int32 FrameHeight = 1080; // Altura padro do frame simulado

private:
    FTimerHandle FrameGenerationTimerHandle; // Handle para o timer de gerao de frames

    float ElapsedTime = 0.0f; // Tempo total desde o incio da simulao
    int64 FrameCount = 0;     // Contador de frames gerados

    FLinearColor FrameTint; // NOVO: Cor de tintura para o frame simulado

    bool IVR_UseRandomPattern = true;
    /**
     * @brief Funcao de callback do timer para gerar e notificar um novo frame simulado.
     */
    UFUNCTION()
    void GenerateSimulatedFrame();

    /**
     * @brief Gera um padro de cor simples para o frame simulado.
     * @param InFrame Um ponteiro para o FIVR_VideoFrame para preencher.
     */
    void FillSimulatedFrame(FIVR_VideoFrame& InFrame);
};
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Recording\IVRSimulatedFrameSource.h ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Recording\IVRVideoEncoder.h ---
#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "Core/IVRTypes.h"
#include "IVR_PipeWrapper.h"     // Para FIVR_PipeWrapper (Assumindo que está em um local acessível)
#include "IVRECFactory.h" // Para UIVRECFactory (Assumindo que está em um local acessível)
#include "HAL/Runnable.h"       // Para FRunnable (worker thread)
#include "Containers/Queue.h"   // Para TQueue (thread-safe queue)
#include "FFmpegLogReader.h"
#include "HAL/ThreadSafeBool.h" // Incluir ThreadSafeBool
#include "Core/IVRFramePool.h" // Adicionar este include!
#include "IVRVideoEncoder.generated.h"

// Definição do LogCategory para esta classe
DECLARE_LOG_CATEGORY_EXTERN(LogIVRVideoEncoder, Log, All);

// Forward declaration da classe worker thread
class FVideoEncoderWorker;

UCLASS(Blueprintable, BlueprintType, meta=(DisplayName="IVR Video Encoder"))
class IVR_API UIVRVideoEncoder : public UObject
{
    GENERATED_BODY()

public:

    UIVRVideoEncoder();
    virtual ~UIVRVideoEncoder();

    // Sobrescreve o BeginDestroy para garantir limpeza de recursos quando o UObject é destruído
    virtual void BeginDestroy() override;

    // Caminho completo para o executável do FFmpeg
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "IVR|Encoder Settings")
    FString FFmpegExecutablePath; // Agora gerado automaticamente, mas pode ser sobrescrito pelo BP

     /**
     * @brief Inicializa o codificador de vídeo, configura o pipe de entrada e o worker thread.
     * @param Settings Configurações de vídeo para a codificação.
     * @param InFFmpegExecutablePath Caminho para o executável FFmpeg.
     * @param InActualFrameWidth Largura real dos frames que serão processados.
     * @param InActualFrameHeight Altura real dos frames que serão processados.
     * @param InFramePool Referência ao pool de frames para gerenciamento de buffers. 
     * @return true se a inicialização foi bem-sucedida, false caso contrário.
     */
    UFUNCTION(BlueprintCallable, Category = "IVR|Encoder")
    bool Initialize(const FIVR_VideoSettings& Settings, const FString& InFFmpegExecutablePath, int32 InActualFrameWidth, int32 InActualFrameHeight, UIVRFramePool* InFramePool); 

    /**
     * @brief Lança o processo principal do FFmpeg para iniciar a gravação ao vivo.
     * @param LiveOutputFilePath Caminho completo para o arquivo de vídeo de saída ao vivo.
     * @return true se o processo FFmpeg foi lançado com sucesso, false caso contrário.
     */
    UFUNCTION(BlueprintCallable, Category = "IVR|Encoder")
    bool LaunchEncoder(const FString& LiveOutputFilePath);

    /**
     * @brief Encerra o codificador e limpa todos os recursos (pipes, processo FFmpeg, threads).
     */
    UFUNCTION(BlueprintCallable, Category = "IVR|Encoder")
    void ShutdownEncoder();

    /**
    * @brief Adiciona um frame de vídeo à fila de codificação.
    * @param Frame O frame de vídeo a ser codificado.
    * @return true se o frame foi adicionado com sucesso, false caso contrário.
    */
    bool EncodeFrame(FIVR_VideoFrame Frame); // Assinatura mudada para receber por valor

    /**
     * @brief Sinaliza que não haverá mais frames para codificar e aguarda a conclusão da escrita no pipe.
     * Isso fecha o pipe de entrada e sinaliza EOF ao FFmpeg.
     * @return true se a finalização foi bem-sucedida, false caso contrário.
     */
    UFUNCTION(BlueprintCallable, Category = "IVR|Encoder")
    bool FinishEncoding();

    /**
     * @brief Concatena uma lista de arquivos de vídeo em um único arquivo mestre usando FFmpeg.
     * @param InTakePaths Array de caminhos completos para os takes individuais.
     * @param InMasterOutputPath Caminho completo para o arquivo de vídeo mestre de saída.
     * @return true se a concatenação foi bem-sucedida, false caso contrário.
     */
    UFUNCTION(BlueprintCallable, Category = "IVR|Encoder")
    bool ConcatenateVideos(const TArray<FString>& InTakePaths, const FString& InMasterOutputPath);

    UFUNCTION(BlueprintPure, Category = "IVR")
    bool IsInitialized() const { return bIsInitialized; }

protected:
    // Configurações de vídeo atuais
    FIVR_VideoSettings CurrentSettings;
    
    // Instância da fábrica de comandos FFmpeg, agora gerenciada por esta classe.
    UPROPERTY()
    UIVRECFactory* EncoderCommandFactory;

    // Handle do processo principal do FFmpeg para a gravação ao vivo
    FProcHandle FFmpegProcHandle;
    FFMpegLogReader* FFmpegStdoutLogReader; // Leitor de log do FFmpeg stdout
    FFMpegLogReader* FFmpegStderrLogReader; // Leitor de log do FFmpeg stderr
    void* FFmpegReadPipeStdout;       // Handle de leitura para o pipe do FFmpeg stdout
    void* FFmpegWritePipeStdout;      // Handle de escrita para o pipe do FFmpeg stdout
    void* FFmpegReadPipeStderr;       // Handle de leitura para o pipe do FFmpeg stderr
    void* FFmpegWritePipeStderr;      // Handle de escrita para o pipe do FFmpeg stderr

    // Wrapper para o Named Pipe de entrada de vídeo (UE -> FFmpeg)
    FIVR_PipeWrapper VideoInputPipe;
    
    // Nome único do pipe de vídeo para esta sessão
    FString VideoPipeBaseName; // Nome base para o pipe

    // Fila thread-safe para frames de vídeo (Mpsc: Multiple Producer, Single Consumer)
    TQueue<FIVR_VideoFrame, EQueueMode::Mpsc> FrameQueue;
    
    // Flag atômica para sinalizar ao worker thread para parar
    FThreadSafeBool bStopWorkerThread;
    
    // Flag atômica para sinalizar que todos os frames foram submetidos (não haverá mais Enqueue)
    FThreadSafeBool bNoMoreFramesToEncode;
    
    // Estado interno para controle de inicialização
    FThreadSafeBool bIsInitialized;

    // Worker thread para escrita no pipe
    FVideoEncoderWorker* WorkerRunnable;
    FRunnableThread* WorkerThread; 
    
    // Evento para sinalizar que novos frames estão disponíveis ou que a thread deve verificar o estado (shutdown/finish)
    FEvent* NewFrameEvent;

     // Largura e altura reais dos frames a serem processados
    int32 ActualProcessingWidth;
    int32 ActualProcessingHeight;

    UPROPERTY() // Adicionar para garantir que o FramePool não seja coletado pelo GC
    UIVRFramePool* FramePool; // Referência ao pool de frames

    /**
     * @brief Função auxiliar para limpar os recursos do encoder (terminar FFmpeg e fechar pipe).
     */
    void InternalCleanupEncoderResources();

    /**
     * @brief Função auxiliar para obter o caminho do executável FFmpeg.
     * @return Caminho completo do executável FFmpeg.
     */
    FString GetFFmpegExecutablePathInternal() const;
};

/**
 * FVideoEncoderWorker
 * Implementa FRunnable para processar a fila de frames e escrevê-los no Named Pipe em um thread separado.
 */
class FVideoEncoderWorker : public FRunnable
{
public:
    FVideoEncoderWorker(UIVRVideoEncoder* InEncoder, TQueue<FIVR_VideoFrame, EQueueMode::Mpsc>& InFrameQueue, FIVR_PipeWrapper& InVideoInputPipe, FThreadSafeBool& InStopFlag, FThreadSafeBool& InNoMoreFramesFlag, FEvent* InNewFrameEvent, UIVRFramePool* InFramePool);
    virtual ~FVideoEncoderWorker();

    // Implementação da interface FRunnable
    virtual bool Init() override;
    virtual uint32 Run() override;
    virtual void Stop() override;
    virtual void Exit() override;

private:
    UIVRVideoEncoder* Encoder; // Ponteiro raw para o UObject pai (para acesso a logs e configurações)
    TQueue<FIVR_VideoFrame, EQueueMode::Mpsc>& FrameQueue; // Referência à fila de frames
    FIVR_PipeWrapper& VideoInputPipe; // Referência ao wrapper do pipe de vídeo
    FThreadSafeBool& bShouldStop; // Referência para a flag de parada da thread
    FThreadSafeBool& bNoMoreFramesToEncode; // Referência para a flag de "sem mais frames"
    FEvent* NewFrameEvent; // Referência ao evento de sinalização
    UIVRFramePool* FramePool; // Referência ao pool de frames para liberar buffers 
};
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Recording\IVRVideoEncoder.h ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Recording\IVRVideoFrameSource.h ---
// Fill out your copyright notice in the Description page of Project Settings.
#pragma once

#include "CoreMinimal.h"
#include "Recording/IVRFrameSource.h"

// Includes para Threading
#include "HAL/Runnable.h"       // Para FRunnable
#include "HAL/RunnableThread.h" // Para FRunnableThread
#include "HAL/ThreadSafeBool.h" // Para FThreadSafeBool
#include "HAL/ThreadSafeCounter.h" // Para FThreadSafeCounter (resolu��o) e FThreadSafeFloat (FPS)
#include "Containers/Queue.h"   // Para TQueue

#include "IVRVideoFrameSource.generated.h"

// Forward declare do worker thread
class FVideoFileCaptureWorker;

/**
 * @brief Fonte de frames que l de um arquivo de vdeo usando OpenCV em um thread separado.
 */
UCLASS(Blueprintable, BlueprintType, meta=(DisplayName="IVR Video File Frame Source"))
class IVR_API UIVRVideoFrameSource : public UIVRFrameSource
{
    GENERATED_BODY()

public:
    UIVRVideoFrameSource();
    virtual void BeginDestroy() override;

    /**
     * @brief Inicializa a fonte de frames de arquivo de vdeo.
     * @param World O UWorld atual.
     * @param Settings As configuraes de vdeo, incluindo o caminho do arquivo e opes de reproduo.
     * @param InFramePool O pool de frames para adquirir e liberar buffers.
     */
    virtual void Initialize(UWorld* World, const FIVR_VideoSettings& Settings, UIVRFramePool* InFramePool) override;

    /**
     * @brief Desliga a fonte de frames e libera seus recursos.
     */
    virtual void Shutdown() override;

    /**
     * @brief Inicia a captura de frames do arquivo de vdeo.
     */
    virtual void StartCapture() override;

    /**
     * @brief Para a captura de frames do arquivo de vdeo.
     */
    virtual void StopCapture() override;

    /**
     * @brief Retorna a largura real do frame lido do arquivo de vdeo.
     * Vlido aps Initialize.
     */
    UFUNCTION(BlueprintPure, Category = "IVR|VideoFile")
    int32 GetActualFrameWidth() const;

    /**
     * @brief Retorna a altura real do frame lido do arquivo de vdeo.
     * Vlido aps Initialize.
     */
    UFUNCTION(BlueprintPure, Category = "IVR|VideoFile")
    int32 GetActualFrameHeight() const;

    /**
     * @brief Retorna o FPS nativo do arquivo de v�deo.
     * V�lido ap�s Initialize.
     */
    UFUNCTION(BlueprintPure, Category = "IVR|VideoFile")
    float GetActualVideoFileFPS() const;
    
    /**
     * @brief Retorna o FPS efetivo de reprodu��o do arquivo de v�deo (FPS nativo * Playback Speed).
     * V�lido ap�s Initialize.
     */
    UFUNCTION(BlueprintPure, Category = "IVR|VideoFile")
    float GetEffectivePlaybackFPS() const;

protected:
    /** Timer handle para polling de frames do worker thread no Game Thread. */
    FTimerHandle FramePollTimerHandle;

    /** Instncia do worker runnable que lida com a leitura do arquivo de vdeo no thread. */
    FVideoFileCaptureWorker* WorkerRunnable;

    /** Thread em que o WorkerRunnable ser executado. */
    FRunnableThread* WorkerThread;

    /** Fila thread-safe para passar frames do worker thread (produtor) para o Game Thread (consumidor). */
    TQueue<FIVR_VideoFrame, EQueueMode::Mpsc> CapturedFrameQueue;

    /** Flag atmica para sinalizar  thread worker para parar. */
    FThreadSafeBool bShouldStopWorker;

    /** Evento para sinalizar novos frames disponveis do worker thread para o Game Thread. */
    FEvent* NewFrameEvent;

    /**
     * @brief Funo de callback do timer para pegar frames da fila e broadcast-los.
     * Executada no Game Thread.
     */
    void PollForNewFrames();
};

--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Recording\IVRVideoFrameSource.h ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Recording\IVRWebcamFrameSource.h ---
#pragma once

#include "CoreMinimal.h"
#include "Recording/IVRFrameSource.h"
#include "Core/IVRFramePool.h"

// Includes para Threading
#include "HAL/Runnable.h"       // Para FRunnable
#include "HAL/RunnableThread.h" // Para FRunnableThread
#include "HAL/ThreadSafeBool.h" // Para FThreadSafeBool
#include "HAL/ThreadSafeCounter.h" // Para FThreadSafeBool
#include "Containers/Queue.h"   // Para TQueue

#include "IVRWebcamFrameSource.generated.h"

// Forward declare do worker thread
class FWebcamCaptureWorker;

/**
 * @brief Fonte de frames que l� de uma webcam usando OpenCV em um thread separado.
 */
UCLASS(Blueprintable, BlueprintType, meta=(DisplayName="IVR Webcam Frame Source"))
class IVR_API UIVRWebcamFrameSource : public UIVRFrameSource
{
    GENERATED_BODY()

public:
    UIVRWebcamFrameSource();
    virtual void BeginDestroy() override;

    /**
     * @brief Inicializa a fonte de frames da webcam.
     * @param World O UWorld atual.
     * @param Settings As configura��es de v�deo, incluindo o �ndice da webcam, resolu��o e FPS.
     * @param InFramePool O pool de frames para adquirir e liberar buffers.
     */
    virtual void Initialize(UWorld* World, const FIVR_VideoSettings& Settings, UIVRFramePool* InFramePool) override;

    /**
     * @brief Desliga a fonte de frames e libera seus recursos.
     */
    virtual void Shutdown() override;

    /**
     * @brief Inicia a captura de frames da webcam.
     */
    virtual void StartCapture() override;

    /**
     * @brief Para a captura de frames da webcam.
     */
    virtual void StopCapture() override;

    /**
     * @brief Lista os dispositivos de webcam dispon�veis no sistema.
     * Tenta abrir os primeiros 10 dispositivos para verificar sua exist�ncia e caracter�sticas.
     * @return Um TArray de FString com descri��es b�sicas dos dispositivos encontrados.
     */
    UFUNCTION(BlueprintCallable, Category = "IVR|Webcam")
    static TArray<FString> ListWebcamDevices();

    /**
    * @brief Retorna a largura real do frame capturado pela webcam.
    * V�lido ap�s Initialize.
    */
    UFUNCTION(BlueprintPure, Category = "IVR|Webcam")
    int32 GetActualFrameWidth() const;

    /**
    * @brief Retorna a altura real do frame capturado pela webcam.
    * V�lido ap�s Initialize.
    */
    UFUNCTION(BlueprintPure, Category = "IVR|Webcam")
    int32 GetActualFrameHeight() const;


protected:
    /** Timer handle para polling de frames do worker thread no Game Thread. */
    FTimerHandle FramePollTimerHandle;

    /** Inst�ncia do worker runnable que lida com a captura da webcam no thread. */
    FWebcamCaptureWorker* WorkerRunnable;

    /** Thread em que o WorkerRunnable ser� executado. */
    FRunnableThread* WorkerThread;

    /** Fila thread-safe para passar frames do worker thread (produtor) para o Game Thread (consumidor). */
    TQueue<FIVR_VideoFrame, EQueueMode::Mpsc> CapturedFrameQueue;

    /** Flag at�mica para sinalizar � thread worker para parar. */
    FThreadSafeBool bShouldStopWorker;

    /** Evento para sinalizar novos frames dispon�veis do worker thread para o Game Thread. */
    FEvent* NewFrameEvent;

    /**
     * @brief Fun��o de callback do timer para pegar frames da fila e broadcast�-los.
     * Executada no Game Thread.
     */
    void PollForNewFrames();
};
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\Recording\IVRWebcamFrameSource.h ---



--- INÃCIO DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\UI\IVRDisplayWidget.h ---
// D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\UI\IVRDisplayWidget.h

#pragma once

#include "CoreMinimal.h"
#include "Blueprint/UserWidget.h"
#include "Components/Image.h" // Necess�rio para UImage
#include "Engine/Texture2D.h" // Necess�rio para UTexture2D
#include "IVRDisplayWidget.generated.h"

/**
 * Widget de exemplo para exibir uma textura 2D.
 * Pode ser herdado em Blueprint para construir a interface visual.
 */
UCLASS()
class IVR_API UIVRDisplayWidget : public UUserWidget
{
    GENERATED_BODY()
    
public:
    // O widget de imagem que ir� exibir a textura.
    // Marque com BindWidget para que o framework UMG o injete automaticamente
    // se houver um UImage com o mesmo nome (DisplayImage) no seu Blueprint Widget.
    UPROPERTY(meta = (BindWidget))
    UImage* DisplayImage;

    /**
     * Define a textura a ser exibida no widget de imagem.
     * @param NewTexture A nova textura a ser usada.
     */
    UFUNCTION(BlueprintCallable, Category = "IVR|Display")
    void SetDisplayTexture(UTexture2D* NewTexture);

protected:
    virtual void NativeConstruct() override;
};
--- FIM DO ARQUIVO: D:\william\UnrealProjects\IACSWorld\Plugins\IVR\Source\IVR\Public\UI\IVRDisplayWidget.h ---



